# HG changeset patch
# Parent  1fca3f09b1ce426986c9e7b9b587700ad159ce67

diff --git a/.hgignore b/.hgignore
new file mode 100644
--- /dev/null
+++ b/.hgignore
@@ -0,0 +1,5 @@
+JCOV_BUILD
+nbproject/private/
+build/private.properties
+build-nb/
+dist/
diff --git a/build.xml b/build.xml
new file mode 100644
--- /dev/null
+++ b/build.xml
@@ -0,0 +1,73 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- You may freely edit this file. See commented blocks below for -->
+<!-- some examples of how to customize the build. -->
+<!-- (If you delete it and reopen the project it will be recreated.) -->
+<!-- By default, only the Clean and Build commands use this build script. -->
+<!-- Commands such as Run, Debug, and Test only use this build script if -->
+<!-- the Compile on Save feature is turned off for the project. -->
+<!-- You can turn off the Compile on Save (or Deploy on Save) setting -->
+<!-- in the project's Project Properties dialog box.-->
+<project name="JCov" default="default" basedir=".">
+    <description>Builds, tests, and runs the project JCov.</description>
+    <import file="nbproject/build-impl.xml"/>
+    <!--
+
+    There exist several targets which are by default empty and which can be 
+    used for execution of your tasks. These targets are usually executed 
+    before and after some main targets. They are: 
+
+      -pre-init:                 called before initialization of project properties
+      -post-init:                called after initialization of project properties
+      -pre-compile:              called before javac compilation
+      -post-compile:             called after javac compilation
+      -pre-compile-single:       called before javac compilation of single file
+      -post-compile-single:      called after javac compilation of single file
+      -pre-compile-test:         called before javac compilation of JUnit tests
+      -post-compile-test:        called after javac compilation of JUnit tests
+      -pre-compile-test-single:  called before javac compilation of single JUnit test
+      -post-compile-test-single: called after javac compilation of single JUunit test
+      -pre-jar:                  called before JAR building
+      -post-jar:                 called after JAR building
+      -post-clean:               called after cleaning build products
+
+    (Targets beginning with '-' are not intended to be called on their own.)
+
+    Example of inserting an obfuscator after compilation could look like this:
+
+        <target name="-post-compile">
+            <obfuscate>
+                <fileset dir="${build.classes.dir}"/>
+            </obfuscate>
+        </target>
+
+    For list of available properties check the imported 
+    nbproject/build-impl.xml file. 
+
+
+    Another way to customize the build is by overriding existing main targets.
+    The targets of interest are: 
+
+      -init-macrodef-javac:     defines macro for javac compilation
+      -init-macrodef-junit:     defines macro for junit execution
+      -init-macrodef-debug:     defines macro for class debugging
+      -init-macrodef-java:      defines macro for class execution
+      -do-jar:                  JAR building
+      run:                      execution of project 
+      -javadoc-build:           Javadoc generation
+      test-report:              JUnit report generation
+
+    An example of overriding the target for project execution could look like this:
+
+        <target name="run" depends="JCov-impl.jar">
+            <exec dir="bin" executable="launcher.exe">
+                <arg file="${dist.jar}"/>
+            </exec>
+        </target>
+
+    Notice that the overridden target depends on the jar target and not only on 
+    the compile target as the regular run target does. Again, for a list of available 
+    properties which you can use, check the target you are overriding in the
+    nbproject/build-impl.xml file. 
+
+    -->
+</project>
diff --git a/build/build.properties b/build/build.properties
--- a/build/build.properties
+++ b/build/build.properties
@@ -22,9 +22,9 @@
 # questions.
 
 # path to asm5 library
-asmjar5 = asm5.jar
+asmjar5 = 
 # path to javatest library (empty value allowed if you do not need jtobserver.jar)
-javatestjar = javatest.jar
+javatestjar = 
 
 # path to output directory
 result.dir =../JCOV_BUILD
diff --git a/build/build.xml b/build/build.xml
--- a/build/build.xml
+++ b/build/build.xml
@@ -27,12 +27,13 @@
 
 <project name="JCov" default="build" basedir=".">
 
+    <property file="private.properties"/>
     <property file="release.properties"/>
     <property file="build.properties"/>
 
     <!-- Build area -->
     <property name="build.dir" location="${result.dir}/jcov_${build.version}"/>
-    <property name="jcov.classpath" value="${asmjar5}:${java.home}/lib/tools.jar"/>
+    <property name="jcov.classpath" value="${asmjar5}:${java.home}/lib/tools.jar:${java.home}/../lib/tools.jar"/>
 
     <!-- Temp dir is for files which do not appear in release directory -->
     <property name="tmp.dir" location="${result.dir}/temp"/>
@@ -62,6 +63,7 @@
         <include name="com/sun/tdk/jcov/util/MapHelper.*"/>
         <include name="com/sun/tdk/jcov/util/RuntimeUtils.*"/>
         <include name="com/sun/tdk/jcov/runtime/TemplateFileSaver*"/>
+        <include name="com/sun/tdk/jcov/runtime/DumpSaver*"/>
         <include name="com/sun/tdk/jcov/util/MapHelper.*"/>
         <include name="com/sun/tdk/jcov/constants/MiscConstants*"/>
     </patternset>
@@ -159,13 +161,13 @@
     <target name="compile"  depends="prepare, build-date"
             description="compile main tools">
 
-        <javac encoding="iso-8859-1" debug="true" target="1.5" source="1.5"
+        <javac encoding="iso-8859-1" debug="true" target="1.8" source="1.8"
                srcdir="${jcov.src.update}"
                destdir="${jcov.classes}"
                classpath="${jcov.classpath}">
         </javac>
 
-        <javac encoding="iso-8859-1" debug="true" target="1.5" source="1.5"
+        <javac encoding="iso-8859-1" debug="true" target="1.8" source="1.8"
                srcdir="${src.dir}"
                destdir="${jcov.classes}"
                classpath="${jcov.classpath}">
@@ -232,11 +234,11 @@
                     <replaceregex pattern="@\*\/" replace="@"/>
                 </tokenfilter>
                 <filterreader classname="org.apache.tools.ant.filters.ReplaceTokens">
-                    <param type="propertiesfile" value="filesaver.replace.properties"/>
+                    <param type="propertiesfile" value="${basedir}/filesaver.replace.properties"/>
                 </filterreader>
             </filterchain>
         </copy>
-        <javac encoding="iso-8859-1" debug="true" target="1.5" source="1.5"
+        <javac encoding="iso-8859-1" debug="true" target="1.8" source="1.8"
                srcdir="${jcov.filesaver.src}"
                sourcepath=""
                classpath="${jcov.filesaver.classes}"
@@ -266,11 +268,11 @@
                     <replaceregex pattern="@\*\/" replace="@"/>
                 </tokenfilter>
                 <filterreader classname="org.apache.tools.ant.filters.ReplaceTokens">
-                    <param type="propertiesfile" value="networksaver.replace.properties"/>
+                    <param type="propertiesfile" value="${basedir}/networksaver.replace.properties"/>
                 </filterreader>
             </filterchain>
         </copy>
-        <javac encoding="iso-8859-1" debug="true" target="1.5" source="1.5"
+        <javac encoding="iso-8859-1" debug="true" target="1.8" source="1.8"
                srcdir="${jcov.networksaver.src}"
                sourcepath=""
                classpath="${jcov.networksaver.classes}"
diff --git a/build/filesaver.replace.properties b/build/filesaver.replace.properties
--- a/build/filesaver.replace.properties
+++ b/build/filesaver.replace.properties
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 
-BUILD_MODIFIED_SAVER_STRING = com.sun.tdk.jcov.runtime.TemplateFileSaver
\ No newline at end of file
+BUILD_MODIFIED_SAVER_STRING = com.sun.tdk.jcov.runtime.DumpSaver
\ No newline at end of file
diff --git a/manifest.mf b/manifest.mf
new file mode 100644
--- /dev/null
+++ b/manifest.mf
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+X-COMMENT: Main-Class will be added automatically by build
+
diff --git a/nbproject/build-impl.xml b/nbproject/build-impl.xml
new file mode 100644
--- /dev/null
+++ b/nbproject/build-impl.xml
@@ -0,0 +1,1654 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+
+For the purpose of easier reading the script
+is divided into following sections:
+
+  - initialization
+  - compilation
+  - jar
+  - execution
+  - debugging
+  - javadoc
+  - test compilation
+  - test execution
+  - test debugging
+  - applet
+  - cleanup
+
+        -->
+<project xmlns:j2seproject1="http://www.netbeans.org/ns/j2se-project/1" xmlns:j2seproject3="http://www.netbeans.org/ns/j2se-project/3" xmlns:jaxrpc="http://www.netbeans.org/ns/j2se-project/jax-rpc" basedir=".." default="default" name="JCov-impl">
+    <fail message="Please build using Ant 1.8.0 or higher.">
+        <condition>
+            <not>
+                <antversion atleast="1.8.0"/>
+            </not>
+        </condition>
+    </fail>
+    <target depends="test,jar,javadoc" description="Build and test whole project." name="default"/>
+    <!-- 
+                ======================
+                INITIALIZATION SECTION 
+                ======================
+            -->
+    <target name="-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init" name="-init-private">
+        <property file="nbproject/private/config.properties"/>
+        <property file="nbproject/private/configs/${config}.properties"/>
+        <property file="nbproject/private/private.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private" name="-init-user">
+        <property file="${user.properties.file}"/>
+        <!-- The two properties below are usually overridden -->
+        <!-- by the active platform. Just a fallback. -->
+        <property name="default.javac.source" value="1.6"/>
+        <property name="default.javac.target" value="1.6"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user" name="-init-project">
+        <property file="nbproject/configs/${config}.properties"/>
+        <property file="nbproject/project.properties"/>
+    </target>
+    <target name="-init-modules-supported">
+        <condition property="modules.supported.internal" value="true">
+            <not>
+                <matches pattern="1\.[0-8](\..*)?" string="${javac.source}"/>
+            </not>
+        </condition>
+    </target>
+    <target depends="-init-modules-supported" if="modules.supported.internal" name="-init-macrodef-modulename">
+        <macrodef name="modulename" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute name="property"/>
+            <attribute name="sourcepath"/>
+            <sequential>
+                <loadresource property="@{property}" quiet="true">
+                    <javaresource classpath="@{sourcepath}" name="module-info.java" parentFirst="false"/>
+                    <filterchain>
+                        <stripjavacomments/>
+                        <linecontainsregexp>
+                            <regexp pattern="module .* \{"/>
+                        </linecontainsregexp>
+                        <tokenfilter>
+                            <linetokenizer/>
+                            <replaceregex flags="s" pattern="(\s*module\s+)(\S*)(\s*\{.*)" replace="\2"/>
+                        </tokenfilter>
+                        <striplinebreaks/>
+                    </filterchain>
+                </loadresource>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-modules-supported,-init-macrodef-modulename" if="modules.supported.internal" name="-init-source-module-properties">
+        <fail message="Java 9 support requires Ant 1.10.0 or higher.">
+            <condition>
+                <not>
+                    <antversion atleast="1.10.0"/>
+                </not>
+            </condition>
+        </fail>
+        <j2seproject3:modulename property="module.name" sourcepath="${src.classes.dir}"/>
+        <condition property="named.module.internal">
+            <and>
+                <isset property="module.name"/>
+                <length length="0" string="${module.name}" when="greater"/>
+            </and>
+        </condition>
+        <condition property="unnamed.module.internal">
+            <not>
+                <isset property="named.module.internal"/>
+            </not>
+        </condition>
+        <property name="javac.modulepath" value=""/>
+        <property name="run.modulepath" value="${javac.modulepath}"/>
+        <property name="module.build.classes.dir" value="${build.classes.dir}"/>
+        <property name="debug.modulepath" value="${run.modulepath}"/>
+        <property name="javac.upgrademodulepath" value=""/>
+        <property name="run.upgrademodulepath" value="${javac.upgrademodulepath}"/>
+        <condition else="" property="javac.systemmodulepath.cmd.line.arg" value="--system '${javac.systemmodulepath}'">
+            <and>
+                <isset property="javac.systemmodulepath"/>
+                <length length="0" string="${javac.systemmodulepath}" when="greater"/>
+            </and>
+        </condition>
+        <property name="module.name" value=""/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property,-init-modules-supported" name="-do-init">
+        <property name="platform.java" value="${java.home}/bin/java"/>
+        <available file="${manifest.file}" property="manifest.available"/>
+        <condition property="splashscreen.available">
+            <and>
+                <not>
+                    <equals arg1="${application.splash}" arg2="" trim="true"/>
+                </not>
+                <available file="${application.splash}"/>
+            </and>
+        </condition>
+        <condition property="main.class.available">
+            <and>
+                <isset property="main.class"/>
+                <not>
+                    <equals arg1="${main.class}" arg2="" trim="true"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="profile.available">
+            <and>
+                <isset property="javac.profile"/>
+                <length length="0" string="${javac.profile}" when="greater"/>
+                <not>
+                    <matches pattern="1\.[0-7](\..*)?" string="${javac.source}"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="do.archive">
+            <or>
+                <not>
+                    <istrue value="${jar.archive.disabled}"/>
+                </not>
+                <istrue value="${not.archive.disabled}"/>
+            </or>
+        </condition>
+        <condition property="do.mkdist">
+            <and>
+                <isset property="do.archive"/>
+                <isset property="libs.CopyLibs.classpath"/>
+                <not>
+                    <istrue value="${mkdist.disabled}"/>
+                </not>
+                <not>
+                    <istrue value="${modules.supported.internal}"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="do.archive+manifest.available">
+            <and>
+                <isset property="manifest.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+main.class.available">
+            <and>
+                <isset property="main.class.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+splashscreen.available">
+            <and>
+                <isset property="splashscreen.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+profile.available">
+            <and>
+                <isset property="profile.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="have.tests">
+            <or>
+                <available file="${test.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="have.sources">
+            <or>
+                <available file="${src.classes.dir}"/>
+            </or>
+        </condition>
+        <condition property="netbeans.home+have.tests">
+            <and>
+                <isset property="netbeans.home"/>
+                <isset property="have.tests"/>
+            </and>
+        </condition>
+        <condition property="no.javadoc.preview">
+            <and>
+                <isset property="javadoc.preview"/>
+                <isfalse value="${javadoc.preview}"/>
+            </and>
+        </condition>
+        <property name="run.jvmargs" value=""/>
+        <property name="run.jvmargs.ide" value=""/>
+        <property name="javac.compilerargs" value=""/>
+        <property name="work.dir" value="${basedir}"/>
+        <condition property="no.deps">
+            <and>
+                <istrue value="${no.dependencies}"/>
+            </and>
+        </condition>
+        <property name="javac.debug" value="true"/>
+        <property name="javadoc.preview" value="true"/>
+        <property name="application.args" value=""/>
+        <property name="source.encoding" value="${file.encoding}"/>
+        <property name="runtime.encoding" value="${source.encoding}"/>
+        <property name="manifest.encoding" value="${source.encoding}"/>
+        <condition property="javadoc.encoding.used" value="${javadoc.encoding}">
+            <and>
+                <isset property="javadoc.encoding"/>
+                <not>
+                    <equals arg1="${javadoc.encoding}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <property name="javadoc.encoding.used" value="${source.encoding}"/>
+        <property name="includes" value="**"/>
+        <property name="excludes" value=""/>
+        <property name="do.depend" value="false"/>
+        <condition property="do.depend.true">
+            <istrue value="${do.depend}"/>
+        </condition>
+        <path id="endorsed.classpath.path" path="${endorsed.classpath}"/>
+        <condition else="" property="endorsed.classpath.cmd.line.arg" value="-Xbootclasspath/p:'${toString:endorsed.classpath.path}'">
+            <and>
+                <isset property="endorsed.classpath"/>
+                <not>
+                    <equals arg1="${endorsed.classpath}" arg2="" trim="true"/>
+                </not>
+            </and>
+        </condition>
+        <condition else="" property="javac.profile.cmd.line.arg" value="-profile ${javac.profile}">
+            <isset property="profile.available"/>
+        </condition>
+        <condition else="false" property="jdkBug6558476">
+            <and>
+                <matches pattern="1\.[56]" string="${java.specification.version}"/>
+                <not>
+                    <os family="unix"/>
+                </not>
+            </and>
+        </condition>
+        <condition else="false" property="javac.fork">
+            <or>
+                <istrue value="${jdkBug6558476}"/>
+                <istrue value="${javac.external.vm}"/>
+            </or>
+        </condition>
+        <property name="jar.index" value="false"/>
+        <property name="jar.index.metainf" value="${jar.index}"/>
+        <property name="copylibs.rebase" value="true"/>
+        <available file="${meta.inf.dir}/persistence.xml" property="has.persistence.xml"/>
+        <condition property="junit.available">
+            <or>
+                <available classname="org.junit.Test" classpath="${run.test.classpath}"/>
+                <available classname="junit.framework.Test" classpath="${run.test.classpath}"/>
+            </or>
+        </condition>
+        <condition property="testng.available">
+            <available classname="org.testng.annotations.Test" classpath="${run.test.classpath}"/>
+        </condition>
+        <condition property="junit+testng.available">
+            <and>
+                <istrue value="${junit.available}"/>
+                <istrue value="${testng.available}"/>
+            </and>
+        </condition>
+        <condition else="testng" property="testng.mode" value="mixed">
+            <istrue value="${junit+testng.available}"/>
+        </condition>
+        <condition else="" property="testng.debug.mode" value="-mixed">
+            <istrue value="${junit+testng.available}"/>
+        </condition>
+        <property name="java.failonerror" value="true"/>
+    </target>
+    <target name="-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init" name="-init-check">
+        <fail unless="src.classes.dir">Must set src.classes.dir</fail>
+        <fail unless="test.src.dir">Must set test.src.dir</fail>
+        <fail unless="build.dir">Must set build.dir</fail>
+        <fail unless="dist.dir">Must set dist.dir</fail>
+        <fail unless="build.classes.dir">Must set build.classes.dir</fail>
+        <fail unless="dist.javadoc.dir">Must set dist.javadoc.dir</fail>
+        <fail unless="build.test.classes.dir">Must set build.test.classes.dir</fail>
+        <fail unless="build.test.results.dir">Must set build.test.results.dir</fail>
+        <fail unless="build.classes.excludes">Must set build.classes.excludes</fail>
+        <fail unless="dist.jar">Must set dist.jar</fail>
+    </target>
+    <target name="-init-macrodef-property">
+        <macrodef name="property" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${@{value}}"/>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-ap-cmdline-properties,-init-source-module-properties" if="modules.supported.internal" name="-init-macrodef-javac-with-module">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.classes.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${javac.modulepath}" name="modulepath"/>
+            <attribute default="${javac.upgrademodulepath}" name="upgrademodulepath"/>
+            <attribute default="${javac.processorpath}" name="processorpath"/>
+            <attribute default="${build.generated.sources.dir}/ap-source-output" name="apgeneratedsrcdir"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="${empty.dir}" name="sourcepath"/>
+            <attribute default="${empty.dir}" name="gensrcdir"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.dir}/empty" name="empty.dir"/>
+                <mkdir dir="${empty.dir}"/>
+                <mkdir dir="@{apgeneratedsrcdir}"/>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" fork="${javac.fork}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <src>
+                        <dirset dir="@{gensrcdir}" erroronmissingdir="false">
+                            <include name="*"/>
+                        </dirset>
+                    </src>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <modulepath>
+                        <path path="@{modulepath}"/>
+                    </modulepath>
+                    <upgrademodulepath>
+                        <path path="@{upgrademodulepath}"/>
+                    </upgrademodulepath>
+                    <compilerarg line="${javac.systemmodulepath.cmd.line.arg}"/>
+                    <compilerarg line="${javac.profile.cmd.line.arg}"/>
+                    <compilerarg line="${javac.compilerargs}"/>
+                    <compilerarg value="-processorpath"/>
+                    <compilerarg path="@{processorpath}:${empty.dir}"/>
+                    <compilerarg line="${ap.processors.internal}"/>
+                    <compilerarg line="${annotation.processing.processor.options}"/>
+                    <compilerarg value="-s"/>
+                    <compilerarg path="@{apgeneratedsrcdir}"/>
+                    <compilerarg line="${ap.proc.none.internal}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-ap-cmdline-properties,-init-source-module-properties" if="ap.supported.internal" name="-init-macrodef-javac-with-processors" unless="modules.supported.internal">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.classes.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${javac.modulepath}" name="modulepath"/>
+            <attribute default="${javac.upgrademodulepath}" name="upgrademodulepath"/>
+            <attribute default="${javac.processorpath}" name="processorpath"/>
+            <attribute default="${build.generated.sources.dir}/ap-source-output" name="apgeneratedsrcdir"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="${empty.dir}" name="sourcepath"/>
+            <attribute default="${empty.dir}" name="gensrcdir"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.dir}/empty" name="empty.dir"/>
+                <mkdir dir="${empty.dir}"/>
+                <mkdir dir="@{apgeneratedsrcdir}"/>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" fork="${javac.fork}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <src>
+                        <dirset dir="@{gensrcdir}" erroronmissingdir="false">
+                            <include name="*"/>
+                        </dirset>
+                    </src>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <compilerarg line="${javac.profile.cmd.line.arg}"/>
+                    <compilerarg line="${javac.compilerargs}"/>
+                    <compilerarg value="-processorpath"/>
+                    <compilerarg path="@{processorpath}:${empty.dir}"/>
+                    <compilerarg line="${ap.processors.internal}"/>
+                    <compilerarg line="${annotation.processing.processor.options}"/>
+                    <compilerarg value="-s"/>
+                    <compilerarg path="@{apgeneratedsrcdir}"/>
+                    <compilerarg line="${ap.proc.none.internal}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-ap-cmdline-properties,-init-source-module-properties" name="-init-macrodef-javac-without-processors" unless="ap.supported.internal">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.classes.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${javac.modulepath}" name="modulepath"/>
+            <attribute default="${javac.upgrademodulepath}" name="upgrademodulepath"/>
+            <attribute default="${javac.processorpath}" name="processorpath"/>
+            <attribute default="${build.generated.sources.dir}/ap-source-output" name="apgeneratedsrcdir"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="${empty.dir}" name="sourcepath"/>
+            <attribute default="${empty.dir}" name="gensrcdir"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.dir}/empty" name="empty.dir"/>
+                <mkdir dir="${empty.dir}"/>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" fork="${javac.fork}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <src>
+                        <dirset dir="@{gensrcdir}" erroronmissingdir="false">
+                            <include name="*"/>
+                        </dirset>
+                    </src>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <compilerarg line="${javac.profile.cmd.line.arg}"/>
+                    <compilerarg line="${javac.compilerargs}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-javac-with-module,-init-macrodef-javac-with-processors,-init-macrodef-javac-without-processors" name="-init-macrodef-javac">
+        <macrodef name="depend" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.classes.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <sequential>
+                <depend cache="${build.dir}/depcache" destdir="@{destdir}" excludes="${excludes}" includes="${includes}" srcdir="@{srcdir}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </depend>
+            </sequential>
+        </macrodef>
+        <macrodef name="force-recompile" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <sequential>
+                <fail unless="javac.includes">Must set javac.includes</fail>
+                <pathconvert pathsep="${line.separator}" property="javac.includes.binary">
+                    <path>
+                        <filelist dir="@{destdir}" files="${javac.includes}"/>
+                    </path>
+                    <globmapper from="*.java" to="*.class"/>
+                </pathconvert>
+                <tempfile deleteonexit="true" property="javac.includesfile.binary"/>
+                <echo file="${javac.includesfile.binary}" message="${javac.includes.binary}"/>
+                <delete>
+                    <files includesfile="${javac.includesfile.binary}"/>
+                </delete>
+                <delete>
+                    <fileset file="${javac.includesfile.binary}"/>
+                </delete>
+            </sequential>
+        </macrodef>
+    </target>
+    <target if="${junit.available}" name="-init-macrodef-junit-init">
+        <condition else="false" property="nb.junit.batch" value="true">
+            <and>
+                <istrue value="${junit.available}"/>
+                <not>
+                    <isset property="test.method"/>
+                </not>
+            </and>
+        </condition>
+        <condition else="false" property="nb.junit.single" value="true">
+            <and>
+                <istrue value="${junit.available}"/>
+                <isset property="test.method"/>
+            </and>
+        </condition>
+    </target>
+    <target name="-init-test-properties">
+        <property name="test.binaryincludes" value="&lt;nothing&gt;"/>
+        <property name="test.binarytestincludes" value=""/>
+        <property name="test.binaryexcludes" value=""/>
+    </target>
+    <target depends="-init-modules-supported" if="modules.supported.internal" name="-init-macrodef-junit-prototype-with-module">
+        <macrodef name="junit-prototype" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <element name="customizePrototype" optional="true"/>
+            <sequential>
+                <property name="junit.forkmode" value="perTest"/>
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
+                    <syspropertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <modulepath>
+                        <path path="${run.test.modulepath}"/>
+                    </modulepath>
+                    <formatter type="brief" usefile="false"/>
+                    <formatter type="xml"/>
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="-ea"/>
+                    <jvmarg line="${run.test.jvmargs}"/>
+                    <customizePrototype/>
+                </junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-modules-supported" name="-init-macrodef-junit-prototype-without-module" unless="modules.supported.internal">
+        <macrodef name="junit-prototype" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <element name="customizePrototype" optional="true"/>
+            <sequential>
+                <property name="junit.forkmode" value="perTest"/>
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
+                    <syspropertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <formatter type="brief" usefile="false"/>
+                    <formatter type="xml"/>
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="-ea"/>
+                    <customizePrototype/>
+                </junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-test-properties,-init-macrodef-junit-prototype-with-module,-init-macrodef-junit-prototype-without-module" if="${nb.junit.single}" name="-init-macrodef-junit-single" unless="${nb.junit.batch}">
+        <macrodef name="junit" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <j2seproject3:junit-prototype>
+                    <customizePrototype>
+                        <test methods="@{testmethods}" name="@{testincludes}" todir="${build.test.results.dir}"/>
+                        <customize/>
+                    </customizePrototype>
+                </j2seproject3:junit-prototype>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-test-properties,-init-macrodef-junit-prototype-with-module,-init-macrodef-junit-prototype-without-module" if="${nb.junit.batch}" name="-init-macrodef-junit-batch" unless="${nb.junit.single}">
+        <macrodef name="junit" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <j2seproject3:junit-prototype>
+                    <customizePrototype>
+                        <batchtest todir="${build.test.results.dir}">
+                            <fileset dir="${test.src.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                                <filename name="@{testincludes}"/>
+                            </fileset>
+                            <fileset dir="${build.test.classes.dir}" excludes="@{excludes},${excludes},${test.binaryexcludes}" includes="${test.binaryincludes}">
+                                <filename name="${test.binarytestincludes}"/>
+                            </fileset>
+                        </batchtest>
+                        <customize/>
+                    </customizePrototype>
+                </j2seproject3:junit-prototype>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-junit-init,-init-macrodef-junit-single, -init-macrodef-junit-batch" if="${junit.available}" name="-init-macrodef-junit"/>
+    <target if="${testng.available}" name="-init-macrodef-testng">
+        <macrodef name="testng" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <condition else="" property="testng.methods.arg" value="@{testincludes}.@{testmethods}">
+                    <isset property="test.method"/>
+                </condition>
+                <union id="test.set">
+                    <fileset dir="${test.src.dir}" excludes="@{excludes},**/*.xml,${excludes}" includes="@{includes}">
+                        <filename name="@{testincludes}"/>
+                    </fileset>
+                </union>
+                <taskdef classname="org.testng.TestNGAntTask" classpath="${run.test.classpath}" name="testng"/>
+                <testng classfilesetref="test.set" failureProperty="tests.failed" listeners="org.testng.reporters.VerboseReporter" methods="${testng.methods.arg}" mode="${testng.mode}" outputdir="${build.test.results.dir}" suitename="JCov" testname="TestNG tests" workingDir="${work.dir}">
+                    <xmlfileset dir="${build.test.classes.dir}" includes="@{testincludes}"/>
+                    <propertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </propertyset>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <customize/>
+                </testng>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-test-impl">
+        <macrodef name="test-impl" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element implicit="true" name="customize" optional="true"/>
+            <sequential>
+                <echo>No tests executed.</echo>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-junit" if="${junit.available}" name="-init-macrodef-junit-impl">
+        <macrodef name="test-impl" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element implicit="true" name="customize" optional="true"/>
+            <sequential>
+                <j2seproject3:junit excludes="@{excludes}" includes="@{includes}" testincludes="@{testincludes}" testmethods="@{testmethods}">
+                    <customize/>
+                </j2seproject3:junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-testng" if="${testng.available}" name="-init-macrodef-testng-impl">
+        <macrodef name="test-impl" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element implicit="true" name="customize" optional="true"/>
+            <sequential>
+                <j2seproject3:testng excludes="@{excludes}" includes="@{includes}" testincludes="@{testincludes}" testmethods="@{testmethods}">
+                    <customize/>
+                </j2seproject3:testng>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-test-impl,-init-macrodef-junit-impl,-init-macrodef-testng-impl" name="-init-macrodef-test">
+        <macrodef name="test" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <sequential>
+                <j2seproject3:test-impl excludes="@{excludes}" includes="@{includes}" testincludes="@{testincludes}" testmethods="@{testmethods}">
+                    <customize>
+                        <jvmarg line="${run.jvmargs}"/>
+                        <jvmarg line="${run.jvmargs.ide}"/>
+                    </customize>
+                </j2seproject3:test-impl>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-junit" if="${junit.available}" name="-init-macrodef-junit-debug-impl">
+        <macrodef name="test-debug-impl" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <element name="customizeDebuggee" optional="true"/>
+            <sequential>
+                <j2seproject3:junit excludes="@{excludes}" includes="@{includes}" testincludes="@{testincludes}" testmethods="@{testmethods}">
+                    <customize>
+                        <jvmarg line="${debug-args-line}"/>
+                        <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                        <customizeDebuggee/>
+                    </customize>
+                </j2seproject3:junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target if="${testng.available}" name="-init-macrodef-testng-debug">
+        <macrodef name="testng-debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${main.class}" name="testClass"/>
+            <attribute default="" name="testMethod"/>
+            <element name="customize2" optional="true"/>
+            <sequential>
+                <condition else="-testclass @{testClass}" property="test.class.or.method" value="-methods @{testClass}.@{testMethod}">
+                    <isset property="test.method"/>
+                </condition>
+                <condition else="-suitename JCov -testname @{testClass} ${test.class.or.method}" property="testng.cmd.args" value="@{testClass}">
+                    <matches pattern=".*\.xml" string="@{testClass}"/>
+                </condition>
+                <delete dir="${build.test.results.dir}" quiet="true"/>
+                <mkdir dir="${build.test.results.dir}"/>
+                <j2seproject3:debug classname="org.testng.TestNG" classpath="${debug.test.classpath}">
+                    <customizeDebuggee>
+                        <customize2/>
+                        <jvmarg value="-ea"/>
+                        <arg line="${testng.debug.mode}"/>
+                        <arg line="-d ${build.test.results.dir}"/>
+                        <arg line="-listener org.testng.reporters.VerboseReporter"/>
+                        <arg line="${testng.cmd.args}"/>
+                    </customizeDebuggee>
+                </j2seproject3:debug>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-testng-debug" if="${testng.available}" name="-init-macrodef-testng-debug-impl">
+        <macrodef name="testng-debug-impl" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${main.class}" name="testClass"/>
+            <attribute default="" name="testMethod"/>
+            <element implicit="true" name="customize2" optional="true"/>
+            <sequential>
+                <j2seproject3:testng-debug testClass="@{testClass}" testMethod="@{testMethod}">
+                    <customize2/>
+                </j2seproject3:testng-debug>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-junit-debug-impl" if="${junit.available}" name="-init-macrodef-test-debug-junit">
+        <macrodef name="test-debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <attribute default="${main.class}" name="testClass"/>
+            <attribute default="" name="testMethod"/>
+            <sequential>
+                <j2seproject3:test-debug-impl excludes="@{excludes}" includes="@{includes}" testincludes="@{testincludes}" testmethods="@{testmethods}">
+                    <customizeDebuggee>
+                        <jvmarg line="${run.jvmargs}"/>
+                        <jvmarg line="${run.jvmargs.ide}"/>
+                    </customizeDebuggee>
+                </j2seproject3:test-debug-impl>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-testng-debug-impl" if="${testng.available}" name="-init-macrodef-test-debug-testng">
+        <macrodef name="test-debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <attribute default="" name="testmethods"/>
+            <attribute default="${main.class}" name="testClass"/>
+            <attribute default="" name="testMethod"/>
+            <sequential>
+                <j2seproject3:testng-debug-impl testClass="@{testClass}" testMethod="@{testMethod}">
+                    <customize2>
+                        <syspropertyset>
+                            <propertyref prefix="test-sys-prop."/>
+                            <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                        </syspropertyset>
+                    </customize2>
+                </j2seproject3:testng-debug-impl>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-test-debug-junit,-init-macrodef-test-debug-testng" name="-init-macrodef-test-debug"/>
+    <!--
+                pre NB7.2 profiling section; consider it deprecated
+            -->
+    <target depends="-profile-pre-init, init, -profile-post-init, -profile-init-macrodef-profile, -profile-init-check" if="profiler.info.jvmargs.agent" name="profile-init"/>
+    <target if="profiler.info.jvmargs.agent" name="-profile-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="profiler.info.jvmargs.agent" name="-profile-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="profiler.info.jvmargs.agent" name="-profile-init-macrodef-profile">
+        <macrodef name="resolve">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${env.@{value}}"/>
+            </sequential>
+        </macrodef>
+        <macrodef name="profile">
+            <attribute default="${main.class}" name="classname"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property environment="env"/>
+                <resolve name="profiler.current.path" value="${profiler.info.pathvar}"/>
+                <java classname="@{classname}" dir="${profiler.info.dir}" failonerror="${java.failonerror}" fork="true" jvm="${profiler.info.jvm}">
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="${profiler.info.jvmargs.agent}"/>
+                    <jvmarg line="${profiler.info.jvmargs}"/>
+                    <env key="${profiler.info.pathvar}" path="${profiler.info.agentpath}:${profiler.current.path}"/>
+                    <arg line="${application.args}"/>
+                    <classpath>
+                        <path path="${run.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-profile-pre-init, init, -profile-post-init, -profile-init-macrodef-profile" if="profiler.info.jvmargs.agent" name="-profile-init-check">
+        <fail unless="profiler.info.jvm">Must set JVM to use for profiling in profiler.info.jvm</fail>
+        <fail unless="profiler.info.jvmargs.agent">Must set profiler agent JVM arguments in profiler.info.jvmargs.agent</fail>
+    </target>
+    <!--
+                end of pre NB7.2 profiling section
+            -->
+    <target depends="-init-debug-args" name="-init-macrodef-nbjpda">
+        <macrodef name="nbjpdastart" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="name"/>
+            <attribute default="${debug.modulepath}" name="modulepath"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <attribute default="" name="stopclassname"/>
+            <sequential>
+                <nbjpdastart addressproperty="jpda.address" name="@{name}" stopclassname="@{stopclassname}" transport="${debug-transport}">
+                    <modulepath>
+                        <path path="@{modulepath}"/>
+                    </modulepath>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </nbjpdastart>
+            </sequential>
+        </macrodef>
+        <macrodef name="nbjpdareload" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${build.classes.dir}" name="dir"/>
+            <sequential>
+                <nbjpdareload>
+                    <fileset dir="@{dir}" includes="${fix.classes}">
+                        <include name="${fix.includes}*.class"/>
+                    </fileset>
+                </nbjpdareload>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-debug-args">
+        <property name="version-output" value="java version &quot;${ant.java.version}"/>
+        <condition property="have-jdk-older-than-1.4">
+            <or>
+                <contains string="${version-output}" substring="java version &quot;1.0"/>
+                <contains string="${version-output}" substring="java version &quot;1.1"/>
+                <contains string="${version-output}" substring="java version &quot;1.2"/>
+                <contains string="${version-output}" substring="java version &quot;1.3"/>
+            </or>
+        </condition>
+        <condition else="-Xdebug" property="debug-args-line" value="-Xdebug -Xnoagent -Djava.compiler=none">
+            <istrue value="${have-jdk-older-than-1.4}"/>
+        </condition>
+        <condition else="dt_socket" property="debug-transport-by-os" value="dt_shmem">
+            <os family="windows"/>
+        </condition>
+        <condition else="${debug-transport-by-os}" property="debug-transport" value="${debug.transport}">
+            <isset property="debug.transport"/>
+        </condition>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-debug">
+        <macrodef name="debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${module.name}" name="modulename"/>
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${debug.modulepath}" name="modulepath"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <element name="customizeDebuggee" optional="true"/>
+            <sequential>
+                <j2seproject1:java classname="@{classname}" classpath="@{classpath}" modulename="@{modulename}" modulepath="@{modulepath}">
+                    <customize>
+                        <jvmarg line="${debug-args-line}"/>
+                        <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                        <customizeDebuggee/>
+                    </customize>
+                </j2seproject1:java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-source-module-properties" if="named.module.internal" name="-init-macrodef-java-with-module">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${module.name}" name="modulename"/>
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${run.modulepath}" name="modulepath"/>
+            <attribute default="${run.upgrademodulepath}" name="upgrademodulepath"/>
+            <attribute default="${run.classpath}" name="classpath"/>
+            <attribute default="jvm" name="jvm"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" failonerror="${java.failonerror}" fork="true" module="@{modulename}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <modulepath>
+                        <pathelement path="@{modulepath}"/>
+                        <pathelement location="${module.build.classes.dir}"/>
+                    </modulepath>
+                    <upgrademodulepath>
+                        <path path="@{upgrademodulepath}"/>
+                    </upgrademodulepath>
+                    <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
+                    <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <jvmarg line="${run.jvmargs.ide}"/>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-source-module-properties" if="unnamed.module.internal" name="-init-macrodef-java-with-unnamed-module">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="" name="modulename"/>
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${run.modulepath}" name="modulepath"/>
+            <attribute default="${run.upgrademodulepath}" name="upgrademodulepath"/>
+            <attribute default="${run.classpath}" name="classpath"/>
+            <attribute default="jvm" name="jvm"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" failonerror="${java.failonerror}" fork="true">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <modulepath>
+                        <path path="@{modulepath}"/>
+                    </modulepath>
+                    <upgrademodulepath>
+                        <path path="@{upgrademodulepath}"/>
+                    </upgrademodulepath>
+                    <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
+                    <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <jvmarg line="${run.jvmargs.ide}"/>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-source-module-properties" name="-init-macrodef-java-without-module" unless="modules.supported.internal">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="" name="modulename"/>
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="" name="modulepath"/>
+            <attribute default="${run.classpath}" name="classpath"/>
+            <attribute default="jvm" name="jvm"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" failonerror="${java.failonerror}" fork="true">
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
+                    <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <jvmarg line="${run.jvmargs.ide}"/>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-java-with-module, -init-macrodef-java-with-unnamed-module, -init-macrodef-java-without-module" name="-init-macrodef-java"/>
+    <target name="-init-macrodef-copylibs">
+        <macrodef name="copylibs" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${manifest.file}" name="manifest"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+                <pathconvert property="run.classpath.without.build.classes.dir">
+                    <path path="${run.classpath}"/>
+                    <map from="${build.classes.dir.resolved}" to=""/>
+                </pathconvert>
+                <pathconvert pathsep=" " property="jar.classpath">
+                    <path path="${run.classpath.without.build.classes.dir}"/>
+                    <chainedmapper>
+                        <flattenmapper/>
+                        <filtermapper>
+                            <replacestring from=" " to="%20"/>
+                        </filtermapper>
+                        <globmapper from="*" to="lib/*"/>
+                    </chainedmapper>
+                </pathconvert>
+                <taskdef classname="org.netbeans.modules.java.j2seproject.copylibstask.CopyLibs" classpath="${libs.CopyLibs.classpath}" name="copylibs"/>
+                <copylibs compress="${jar.compress}" excludeFromCopy="${copylibs.excludes}" index="${jar.index}" indexMetaInf="${jar.index.metainf}" jarfile="${dist.jar}" manifest="@{manifest}" manifestencoding="UTF-8" rebase="${copylibs.rebase}" runtimeclasspath="${run.classpath.without.build.classes.dir}">
+                    <fileset dir="${build.classes.dir}" excludes="${dist.archive.excludes}"/>
+                    <manifest>
+                        <attribute name="Class-Path" value="${jar.classpath}"/>
+                        <customize/>
+                    </manifest>
+                </copylibs>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-presetdef-jar">
+        <presetdef name="jar" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <jar compress="${jar.compress}" index="${jar.index}" jarfile="${dist.jar}" manifestencoding="UTF-8">
+                <j2seproject1:fileset dir="${build.classes.dir}" excludes="${dist.archive.excludes}"/>
+            </jar>
+        </presetdef>
+    </target>
+    <target name="-init-ap-cmdline-properties">
+        <property name="annotation.processing.enabled" value="true"/>
+        <property name="annotation.processing.processors.list" value=""/>
+        <property name="annotation.processing.processor.options" value=""/>
+        <property name="annotation.processing.run.all.processors" value="true"/>
+        <property name="javac.processorpath" value="${javac.classpath}"/>
+        <property name="javac.test.processorpath" value="${javac.test.classpath}"/>
+        <condition property="ap.supported.internal" value="true">
+            <not>
+                <matches pattern="1\.[0-5](\..*)?" string="${javac.source}"/>
+            </not>
+        </condition>
+    </target>
+    <target depends="-init-ap-cmdline-properties" if="ap.supported.internal" name="-init-ap-cmdline-supported">
+        <condition else="" property="ap.processors.internal" value="-processor ${annotation.processing.processors.list}">
+            <isfalse value="${annotation.processing.run.all.processors}"/>
+        </condition>
+        <condition else="" property="ap.proc.none.internal" value="-proc:none">
+            <isfalse value="${annotation.processing.enabled}"/>
+        </condition>
+    </target>
+    <target depends="-init-ap-cmdline-properties,-init-ap-cmdline-supported" name="-init-ap-cmdline">
+        <property name="ap.cmd.line.internal" value=""/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init,-post-init,-init-check,-init-macrodef-property,-init-macrodef-javac,-init-macrodef-test,-init-macrodef-test-debug,-init-macrodef-nbjpda,-init-macrodef-debug,-init-macrodef-java,-init-presetdef-jar,-init-ap-cmdline" name="init"/>
+    <!--
+                ===================
+                COMPILATION SECTION
+                ===================
+            -->
+    <target name="-deps-jar-init" unless="built-jar.properties">
+        <property location="${build.dir}/built-jar.properties" name="built-jar.properties"/>
+        <delete file="${built-jar.properties}" quiet="true"/>
+    </target>
+    <target if="already.built.jar.${basedir}" name="-warn-already-built-jar">
+        <echo level="warn" message="Cycle detected: JCov was already built"/>
+    </target>
+    <target depends="init,-deps-jar-init" name="deps-jar" unless="no.deps">
+        <mkdir dir="${build.dir}"/>
+        <touch file="${built-jar.properties}" verbose="false"/>
+        <property file="${built-jar.properties}" prefix="already.built.jar."/>
+        <antcall target="-warn-already-built-jar"/>
+        <propertyfile file="${built-jar.properties}">
+            <entry key="${basedir}" value=""/>
+        </propertyfile>
+    </target>
+    <target depends="init,-check-automatic-build,-clean-after-automatic-build" name="-verify-automatic-build"/>
+    <target depends="init" name="-check-automatic-build">
+        <available file="${build.classes.dir}/.netbeans_automatic_build" property="netbeans.automatic.build"/>
+    </target>
+    <target depends="init" if="netbeans.automatic.build" name="-clean-after-automatic-build">
+        <antcall target="clean">
+            <param name="no.dependencies" value="true"/>
+        </antcall>
+    </target>
+    <target depends="init,deps-jar" name="-pre-pre-compile">
+        <mkdir dir="${build.classes.dir}"/>
+    </target>
+    <target name="-pre-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-depend">
+        <pathconvert property="build.generated.subdirs">
+            <dirset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="*"/>
+            </dirset>
+        </pathconvert>
+        <j2seproject3:depend srcdir="${src.classes.dir}:${build.generated.subdirs}"/>
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile,-pre-compile, -copy-persistence-xml,-compile-depend" if="have.sources" name="-do-compile">
+        <j2seproject3:javac gensrcdir="${build.generated.sources.dir}"/>
+        <copy todir="${build.classes.dir}">
+            <fileset dir="${src.classes.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target if="has.persistence.xml" name="-copy-persistence-xml">
+        <mkdir dir="${build.classes.dir}/META-INF"/>
+        <copy todir="${build.classes.dir}/META-INF">
+            <fileset dir="${meta.inf.dir}" includes="persistence.xml orm.xml"/>
+        </copy>
+    </target>
+    <target name="-post-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile,-do-compile,-post-compile" description="Compile project." name="compile"/>
+    <target name="-pre-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile" name="-do-compile-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile/>
+        <j2seproject3:javac excludes="" gensrcdir="${build.generated.sources.dir}" includes="${javac.includes}, module-info.java" sourcepath="${src.classes.dir}"/>
+    </target>
+    <target name="-post-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile-single,-do-compile-single,-post-compile-single" name="compile-single"/>
+    <!--
+                ====================
+                JAR BUILDING SECTION
+                ====================
+            -->
+    <target depends="init" name="-pre-pre-jar">
+        <dirname file="${dist.jar}" property="dist.jar.dir"/>
+        <mkdir dir="${dist.jar.dir}"/>
+    </target>
+    <target name="-pre-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init" if="do.archive" name="-do-jar-create-manifest" unless="manifest.available">
+        <tempfile deleteonexit="true" destdir="${build.dir}" property="tmp.manifest.file"/>
+        <touch file="${tmp.manifest.file}" verbose="false"/>
+    </target>
+    <target depends="init" if="do.archive+manifest.available" name="-do-jar-copy-manifest">
+        <tempfile deleteonexit="true" destdir="${build.dir}" property="tmp.manifest.file"/>
+        <copy encoding="${manifest.encoding}" file="${manifest.file}" outputencoding="UTF-8" tofile="${tmp.manifest.file}"/>
+    </target>
+    <target depends="init,-do-jar-create-manifest,-do-jar-copy-manifest" if="do.archive+main.class.available" name="-do-jar-set-mainclass">
+        <manifest encoding="UTF-8" file="${tmp.manifest.file}" mode="update">
+            <attribute name="Main-Class" value="${main.class}"/>
+        </manifest>
+    </target>
+    <target depends="init,-do-jar-create-manifest,-do-jar-copy-manifest" if="do.archive+profile.available" name="-do-jar-set-profile">
+        <manifest encoding="UTF-8" file="${tmp.manifest.file}" mode="update">
+            <attribute name="Profile" value="${javac.profile}"/>
+        </manifest>
+    </target>
+    <target depends="init,-do-jar-create-manifest,-do-jar-copy-manifest" if="do.archive+splashscreen.available" name="-do-jar-set-splashscreen">
+        <basename file="${application.splash}" property="splashscreen.basename"/>
+        <mkdir dir="${build.classes.dir}/META-INF"/>
+        <copy failonerror="false" file="${application.splash}" todir="${build.classes.dir}/META-INF"/>
+        <manifest encoding="UTF-8" file="${tmp.manifest.file}" mode="update">
+            <attribute name="SplashScreen-Image" value="META-INF/${splashscreen.basename}"/>
+        </manifest>
+    </target>
+    <target depends="init,-init-macrodef-copylibs,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen" if="do.mkdist" name="-do-jar-copylibs">
+        <j2seproject3:copylibs manifest="${tmp.manifest.file}"/>
+        <echo level="info">To run this application from the command line without Ant, try:</echo>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <echo level="info">java -jar "${dist.jar.resolved}"</echo>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen" if="do.archive" name="-do-jar-jar" unless="do.mkdist">
+        <j2seproject1:jar manifest="${tmp.manifest.file}"/>
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <pathconvert property="run.classpath.with.dist.jar">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to="${dist.jar.resolved}"/>
+        </pathconvert>
+        <pathconvert property="run.modulepath.with.dist.jar">
+            <path path="${run.modulepath}"/>
+            <map from="${build.classes.dir.resolved}" to="${dist.jar.resolved}"/>
+        </pathconvert>
+        <condition else="" property="jar.usage.message.module.path" value=" --module-path ${run.modulepath.with.dist.jar}">
+            <and>
+                <isset property="modules.supported.internal"/>
+                <length length="0" string="${run.modulepath.with.dist.jar}" when="greater"/>
+            </and>
+        </condition>
+        <condition else="" property="jar.usage.message.class.path" value=" -cp ${run.classpath.with.dist.jar}">
+            <length length="0" string="${run.classpath.with.dist.jar}" when="greater"/>
+        </condition>
+        <condition else=" ${main.class}" property="jar.usage.message.main.class" value=" -m ${module.name}/${main.class}">
+            <isset property="named.module.internal"/>
+        </condition>
+        <condition else="" property="jar.usage.message" value="To run this application from the command line without Ant, try:${line.separator}${platform.java}${jar.usage.message.module.path}${jar.usage.message.class.path}${jar.usage.message.main.class}">
+            <isset property="main.class.available"/>
+        </condition>
+        <condition else="debug" property="jar.usage.level" value="info">
+            <isset property="main.class.available"/>
+        </condition>
+        <echo level="${jar.usage.level}" message="${jar.usage.message}"/>
+    </target>
+    <target depends="-do-jar-copylibs" if="do.archive" name="-do-jar-delete-manifest">
+        <delete>
+            <fileset file="${tmp.manifest.file}"/>
+        </delete>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen,-do-jar-jar,-do-jar-delete-manifest" name="-do-jar-without-libraries"/>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen,-do-jar-copylibs,-do-jar-delete-manifest" name="-do-jar-with-libraries"/>
+    <target name="-post-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-jar,-do-jar-without-libraries,-do-jar-with-libraries,-post-jar" name="-do-jar"/>
+    <target depends="init,compile,-pre-jar,-do-jar,-post-jar" description="Build JAR." name="jar"/>
+    <!--
+                =================
+                EXECUTION SECTION
+                =================
+            -->
+    <target depends="init,compile" description="Run a main class." name="run">
+        <j2seproject1:java>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <target name="-do-not-recompile">
+        <property name="javac.includes.binary" value=""/>
+    </target>
+    <target depends="init,compile-single" name="run-single">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}"/>
+    </target>
+    <target depends="init,compile-test-single" name="run-test-with-main">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}" classpath="${run.test.classpath}"/>
+    </target>
+    <!--
+                =================
+                DEBUGGING SECTION
+                =================
+            -->
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger">
+        <j2seproject1:nbjpdastart name="${debug.class}"/>
+    </target>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-main-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${debug.class}"/>
+    </target>
+    <target depends="init,compile" name="-debug-start-debuggee">
+        <j2seproject3:debug>
+            <customizeDebuggee>
+                <arg line="${application.args}"/>
+            </customizeDebuggee>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile,-debug-start-debugger,-debug-start-debuggee" description="Debug project in IDE." if="netbeans.home" name="debug"/>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-stepinto">
+        <j2seproject1:nbjpdastart stopclassname="${main.class}"/>
+    </target>
+    <target depends="init,compile,-debug-start-debugger-stepinto,-debug-start-debuggee" if="netbeans.home" name="debug-stepinto"/>
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-single">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}"/>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-single" if="netbeans.home" name="debug-single"/>
+    <target depends="init,compile-test-single" if="netbeans.home" name="-debug-start-debuggee-main-test">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}" classpath="${debug.test.classpath}"/>
+    </target>
+    <target depends="init,compile-test-single,-debug-start-debugger-main-test,-debug-start-debuggee-main-test" if="netbeans.home" name="debug-test-with-main"/>
+    <target depends="init" name="-pre-debug-fix">
+        <fail unless="fix.includes">Must set fix.includes</fail>
+        <property name="javac.includes" value="${fix.includes}.java"/>
+    </target>
+    <target depends="init,-pre-debug-fix,compile-single" if="netbeans.home" name="-do-debug-fix">
+        <j2seproject1:nbjpdareload/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix" if="netbeans.home" name="debug-fix"/>
+    <!--
+                =================
+                PROFILING SECTION
+                =================
+            -->
+    <!--
+                pre NB7.2 profiler integration
+            -->
+    <target depends="profile-init,compile" description="Profile a project in the IDE." if="profiler.info.jvmargs.agent" name="-profile-pre72">
+        <fail unless="netbeans.home">This target only works when run from inside the NetBeans IDE.</fail>
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile/>
+    </target>
+    <target depends="profile-init,compile-single" description="Profile a selected class in the IDE." if="profiler.info.jvmargs.agent" name="-profile-single-pre72">
+        <fail unless="profile.class">Must select one file in the IDE or set profile.class</fail>
+        <fail unless="netbeans.home">This target only works when run from inside the NetBeans IDE.</fail>
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile classname="${profile.class}"/>
+    </target>
+    <target depends="profile-init,compile-single" if="profiler.info.jvmargs.agent" name="-profile-applet-pre72">
+        <fail unless="netbeans.home">This target only works when run from inside the NetBeans IDE.</fail>
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </profile>
+    </target>
+    <target depends="-init-macrodef-junit,profile-init,compile-test-single" if="profiler.info.jvmargs.agent" name="-profile-test-single-pre72">
+        <fail unless="netbeans.home">This target only works when run from inside the NetBeans IDE.</fail>
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.test.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <j2seproject3:junit excludes="${excludes}" includes="${includes}" testincludes="${profile.class}" testmethods="">
+            <customize>
+                <jvmarg line="${debug-args-line}"/>
+                <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                <env key="${profiler.info.pathvar}" path="${profiler.info.agentpath}:${profiler.current.path}"/>
+                <jvmarg value="${profiler.info.jvmargs.agent}"/>
+                <jvmarg line="${profiler.info.jvmargs}"/>
+                <classpath>
+                    <path path="${run.test.classpath}"/>
+                </classpath>
+            </customize>
+        </j2seproject3:junit>
+    </target>
+    <!--
+                end of pre NB72 profiling section
+            -->
+    <target if="netbeans.home" name="-profile-check">
+        <condition property="profiler.configured">
+            <or>
+                <contains casesensitive="true" string="${run.jvmargs.ide}" substring="-agentpath:"/>
+                <contains casesensitive="true" string="${run.jvmargs.ide}" substring="-javaagent:"/>
+            </or>
+        </condition>
+    </target>
+    <target depends="-profile-check,-profile-pre72" description="Profile a project in the IDE." if="profiler.configured" name="profile" unless="profiler.info.jvmargs.agent">
+        <startprofiler/>
+        <antcall target="run"/>
+    </target>
+    <target depends="-profile-check,-profile-single-pre72" description="Profile a selected class in the IDE." if="profiler.configured" name="profile-single" unless="profiler.info.jvmargs.agent">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <startprofiler/>
+        <antcall target="run-single"/>
+    </target>
+    <target depends="-profile-test-single-pre72" description="Profile a selected test in the IDE." name="profile-test-single"/>
+    <target depends="-profile-check" description="Profile a selected test in the IDE." if="profiler.configured" name="profile-test" unless="profiler.info.jvmargs">
+        <fail unless="test.includes">Must select some files in the IDE or set test.includes</fail>
+        <startprofiler/>
+        <antcall target="test-single"/>
+    </target>
+    <target depends="-profile-check" description="Profile a selected class in the IDE." if="profiler.configured" name="profile-test-with-main">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <startprofiler/>
+        <antcall target="run-test-with-main"/>
+    </target>
+    <target depends="-profile-check,-profile-applet-pre72" if="profiler.configured" name="profile-applet" unless="profiler.info.jvmargs.agent">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <startprofiler/>
+        <antcall target="run-applet"/>
+    </target>
+    <!--
+                ===============
+                JAVADOC SECTION
+                ===============
+            -->
+    <target depends="init" if="have.sources" name="-javadoc-build">
+        <mkdir dir="${dist.javadoc.dir}"/>
+        <condition else="" property="javadoc.endorsed.classpath.cmd.line.arg" value="-J${endorsed.classpath.cmd.line.arg}">
+            <and>
+                <isset property="endorsed.classpath.cmd.line.arg"/>
+                <not>
+                    <equals arg1="${endorsed.classpath.cmd.line.arg}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <condition else="" property="bug5101868workaround" value="*.java">
+            <matches pattern="1\.[56](\..*)?" string="${java.version}"/>
+        </condition>
+        <javadoc additionalparam="-J-Dfile.encoding=${file.encoding} ${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
+            <classpath>
+                <path path="${javac.classpath}"/>
+            </classpath>
+            <fileset dir="${src.classes.dir}" excludes="${bug5101868workaround},${excludes}" includes="${includes}">
+                <filename name="**/*.java"/>
+            </fileset>
+            <fileset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="**/*.java"/>
+                <exclude name="*.java"/>
+            </fileset>
+            <arg line="${javadoc.endorsed.classpath.cmd.line.arg}"/>
+        </javadoc>
+        <copy todir="${dist.javadoc.dir}">
+            <fileset dir="${src.classes.dir}" excludes="${excludes}" includes="${includes}">
+                <filename name="**/doc-files/**"/>
+            </fileset>
+            <fileset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="**/doc-files/**"/>
+            </fileset>
+        </copy>
+    </target>
+    <target depends="init,-javadoc-build" if="netbeans.home" name="-javadoc-browse" unless="no.javadoc.preview">
+        <nbbrowse file="${dist.javadoc.dir}/index.html"/>
+    </target>
+    <target depends="init,-javadoc-build,-javadoc-browse" description="Build Javadoc." name="javadoc"/>
+    <!--
+                =========================
+                TEST COMPILATION SECTION
+                =========================
+            -->
+    <target depends="init,compile" if="have.tests" name="-pre-pre-compile-test">
+        <mkdir dir="${build.test.classes.dir}"/>
+    </target>
+    <target name="-pre-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-init-source-module-properties" if="named.module.internal" name="-init-test-javac-module-properties-with-module">
+        <j2seproject3:modulename property="test.module.name" sourcepath="${test.src.dir}"/>
+        <condition else="-Xmodule:${module.name} --add-reads ${module.name}=ALL-UNNAMED" property="javac.test.compilerargs" value="--add-reads ${test.module.name}=ALL-UNNAMED">
+            <and>
+                <isset property="test.module.name"/>
+                <length length="0" string="${test.module.name}" when="greater"/>
+            </and>
+        </condition>
+    </target>
+    <target depends="-init-source-module-properties" if="named.module.internal" name="-init-test-run-module-properties">
+        <condition else="${module.name}" property="run.test.addexport.source.module.internal" value="${test.module.name}">
+            <and>
+                <isset property="test.module.name"/>
+                <length length="0" string="${test.module.name}" when="greater"/>
+            </and>
+        </condition>
+        <fileset dir="${build.test.classes.dir}" id="run.test.packages.internal" includes="**/*.class"/>
+        <property location="${build.test.classes.dir}" name="build.test.classes.dir.abs.internal"/>
+        <pathconvert pathsep=" " property="run.test.addexports.internal" refid="run.test.packages.internal">
+            <chainedmapper>
+                <regexpmapper from="^(.*)\Q${file.separator}\E.*\.class$$" to="\1"/>
+                <filtermapper>
+                    <uniqfilter/>
+                    <replacestring from="${build.test.classes.dir.abs.internal}" to=""/>
+                </filtermapper>
+                <cutdirsmapper dirs="1"/>
+                <packagemapper from="*" to="--add-exports ${run.test.addexport.source.module.internal}/*=ALL-UNNAMED"/>
+            </chainedmapper>
+        </pathconvert>
+        <condition else="--patch-module ${module.name}=${build.test.classes.dir} --add-modules ${module.name} --add-reads ${module.name}=ALL-UNNAMED ${run.test.addexports.internal}" property="run.test.jvmargs" value="--add-modules ${test.module.name} --add-reads ${test.module.name}=ALL-UNNAMED ${run.test.addexports.internal}">
+            <and>
+                <isset property="test.module.name"/>
+                <length length="0" string="${test.module.name}" when="greater"/>
+            </and>
+        </condition>
+    </target>
+    <target depends="-init-source-module-properties" name="-init-test-module-properties-without-module" unless="named.module.internal">
+        <property name="javac.test.compilerargs" value=""/>
+        <property name="run.test.jvmargs" value=""/>
+    </target>
+    <target depends="-init-test-javac-module-properties-with-module,-init-test-module-properties-without-module" name="-init-test-module-properties"/>
+    <target if="do.depend.true" name="-compile-test-depend">
+        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+    </target>
+    <target depends="init,deps-jar,compile,-init-test-module-properties,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend" if="have.tests" name="-do-compile-test">
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" modulepath="${javac.test.modulepath}" processorpath="${javac.test.processorpath}" srcdir="${test.src.dir}">
+            <customize>
+                <compilerarg line="${javac.test.compilerargs}"/>
+            </customize>
+        </j2seproject3:javac>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-do-compile-test,-post-compile-test" name="compile-test"/>
+    <target name="-pre-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,compile,-init-test-module-properties,-pre-pre-compile-test,-pre-compile-test-single" if="have.tests" name="-do-compile-test-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile destdir="${build.test.classes.dir}"/>
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}, module-info.java" modulepath="${javac.test.modulepath}" processorpath="${javac.test.processorpath}" sourcepath="${test.src.dir}" srcdir="${test.src.dir}">
+            <customize>
+                <compilerarg line="${javac.test.compilerargs}"/>
+            </customize>
+        </j2seproject3:javac>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single,-do-compile-test-single,-post-compile-test-single" name="compile-test-single"/>
+    <!--
+                =======================
+                TEST EXECUTION SECTION
+                =======================
+            -->
+    <target depends="init" if="have.tests" name="-pre-test-run">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test,-init-test-run-module-properties,-pre-test-run" if="have.tests" name="-do-test-run">
+        <j2seproject3:test includes="${includes}" testincludes="**/*Test.java"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run" if="have.tests" name="-post-test-run">
+        <fail if="tests.failed" unless="ignore.failing.tests">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init" if="have.tests" name="test-report"/>
+    <target depends="init" if="netbeans.home+have.tests" name="-test-browse"/>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run,test-report,-post-test-run,-test-browse" description="Run unit tests." name="test"/>
+    <target depends="init" if="have.tests" name="-pre-test-run-single">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test-single,-init-test-run-module-properties,-pre-test-run-single" if="have.tests" name="-do-test-run-single">
+        <fail unless="test.includes">Must select some files in the IDE or set test.includes</fail>
+        <j2seproject3:test excludes="" includes="${test.includes}" testincludes="${test.includes}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single" if="have.tests" name="-post-test-run-single">
+        <fail if="tests.failed" unless="ignore.failing.tests">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init,compile-test-single,-init-test-run-module-properties,-pre-test-run-single,-do-test-run-single,-post-test-run-single" description="Run single unit test." name="test-single"/>
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-do-test-run-single-method">
+        <fail unless="test.class">Must select some files in the IDE or set test.class</fail>
+        <fail unless="test.method">Must select some method in the IDE or set test.method</fail>
+        <j2seproject3:test excludes="" includes="${javac.includes}" testincludes="${test.class}" testmethods="${test.method}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single-method" if="have.tests" name="-post-test-run-single-method">
+        <fail if="tests.failed" unless="ignore.failing.tests">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init,compile-test-single,-init-test-run-module-properties,-pre-test-run-single,-do-test-run-single-method,-post-test-run-single-method" description="Run single unit test." name="test-single-method"/>
+    <!--
+                =======================
+                TEST DEBUGGING SECTION
+                =======================
+            -->
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-debug-start-debuggee-test">
+        <fail unless="test.class">Must select one file in the IDE or set test.class</fail>
+        <j2seproject3:test-debug excludes="" includes="${javac.includes}" testClass="${test.class}" testincludes="${javac.includes}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-debug-start-debuggee-test-method">
+        <fail unless="test.class">Must select one file in the IDE or set test.class</fail>
+        <fail unless="test.method">Must select some method in the IDE or set test.method</fail>
+        <j2seproject3:test-debug excludes="" includes="${javac.includes}" testClass="${test.class}" testMethod="${test.method}" testincludes="${test.class}" testmethods="${test.method}"/>
+    </target>
+    <target depends="init,compile-test" if="netbeans.home+have.tests" name="-debug-start-debugger-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${test.class}"/>
+    </target>
+    <target depends="init,compile-test-single,-init-test-run-module-properties,-debug-start-debugger-test,-debug-start-debuggee-test" name="debug-test"/>
+    <target depends="init,compile-test-single,-init-test-run-module-properties,-debug-start-debugger-test,-debug-start-debuggee-test-method" name="debug-test-method"/>
+    <target depends="init,-pre-debug-fix,compile-test-single" if="netbeans.home" name="-do-debug-fix-test">
+        <j2seproject1:nbjpdareload dir="${build.test.classes.dir}"/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix-test" if="netbeans.home" name="debug-fix-test"/>
+    <!--
+                =========================
+                APPLET EXECUTION SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" name="run-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject1:java classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <!--
+                =========================
+                APPLET DEBUGGING  SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject3:debug classname="sun.applet.AppletViewer">
+            <customizeDebuggee>
+                <arg value="${applet.url}"/>
+            </customizeDebuggee>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-applet" if="netbeans.home" name="debug-applet"/>
+    <!--
+                ===============
+                CLEANUP SECTION
+                ===============
+            -->
+    <target name="-deps-clean-init" unless="built-clean.properties">
+        <property location="${build.dir}/built-clean.properties" name="built-clean.properties"/>
+        <delete file="${built-clean.properties}" quiet="true"/>
+    </target>
+    <target if="already.built.clean.${basedir}" name="-warn-already-built-clean">
+        <echo level="warn" message="Cycle detected: JCov was already built"/>
+    </target>
+    <target depends="init,-deps-clean-init" name="deps-clean" unless="no.deps">
+        <mkdir dir="${build.dir}"/>
+        <touch file="${built-clean.properties}" verbose="false"/>
+        <property file="${built-clean.properties}" prefix="already.built.clean."/>
+        <antcall target="-warn-already-built-clean"/>
+        <propertyfile file="${built-clean.properties}">
+            <entry key="${basedir}" value=""/>
+        </propertyfile>
+    </target>
+    <target depends="init" name="-do-clean">
+        <delete dir="${build.dir}"/>
+        <delete dir="${dist.dir}" followsymlinks="false" includeemptydirs="true"/>
+    </target>
+    <target name="-post-clean">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-clean,-do-clean,-post-clean" description="Clean build products." name="clean"/>
+    <target name="-check-call-dep">
+        <property file="${call.built.properties}" prefix="already.built."/>
+        <condition property="should.call.dep">
+            <and>
+                <not>
+                    <isset property="already.built.${call.subproject}"/>
+                </not>
+                <available file="${call.script}"/>
+            </and>
+        </condition>
+    </target>
+    <target depends="-check-call-dep" if="should.call.dep" name="-maybe-call-dep">
+        <ant antfile="${call.script}" inheritall="false" target="${call.target}">
+            <propertyset>
+                <propertyref prefix="transfer."/>
+                <mapper from="transfer.*" to="*" type="glob"/>
+            </propertyset>
+        </ant>
+    </target>
+</project>
diff --git a/nbproject/genfiles.properties b/nbproject/genfiles.properties
new file mode 100644
--- /dev/null
+++ b/nbproject/genfiles.properties
@@ -0,0 +1,8 @@
+build.xml.data.CRC32=7f84474a
+build.xml.script.CRC32=e2d12cb4
+build.xml.stylesheet.CRC32=8064a381@1.80.0.48
+# This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
+# Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
+nbproject/build-impl.xml.data.CRC32=7f84474a
+nbproject/build-impl.xml.script.CRC32=3f289837
+nbproject/build-impl.xml.stylesheet.CRC32=8bfb4394@1.85.0.48
diff --git a/nbproject/project.properties b/nbproject/project.properties
new file mode 100644
--- /dev/null
+++ b/nbproject/project.properties
@@ -0,0 +1,94 @@
+annotation.processing.enabled=true
+annotation.processing.enabled.in.editor=false
+annotation.processing.processors.list=
+annotation.processing.run.all.processors=true
+annotation.processing.source.output=${build.generated.sources.dir}/ap-source-output
+application.title=JCov
+application.vendor=lahvac
+build.classes.dir=${build.dir}/classes
+build.classes.excludes=**/*.java,**/*.form
+# This directory is removed when the project is cleaned:
+build.dir=build-nb
+build.generated.dir=${build.dir}/generated
+build.generated.sources.dir=${build.dir}/generated-sources
+# Only compile against the classpath explicitly listed here:
+build.sysclasspath=ignore
+build.test.classes.dir=${build.dir}/test/classes
+build.test.results.dir=${build.dir}/test/results
+# Uncomment to specify the preferred debugger connection transport:
+#debug.transport=dt_socket
+debug.classpath=\
+    ${run.classpath}
+debug.modulepath=\
+    ${run.modulepath}
+debug.test.classpath=\
+    ${run.test.classpath}
+debug.test.modulepath=\
+    ${run.test.modulepath}
+# Files in build.classes.dir which should be excluded from distribution jar
+dist.archive.excludes=
+# This directory is removed when the project is cleaned:
+dist.dir=dist
+dist.jar=${dist.dir}/jcov.jar
+dist.javadoc.dir=${dist.dir}/javadoc
+endorsed.classpath=
+excludes=com/sun/tdk/jcov/ant/AllTasks.java,com/sun/tdk/jcov/ant/G*,com/sun/tdk/jcov/ant/I*,com/sun/tdk/jcov/ant/M*,com/sun/tdk/jcov/ant/R*
+file.reference.asm-debug-all-6.0_ALPHA.jar=../asm-debug-all-6.0_ALPHA.jar
+file.reference.javatest.jar=../release/modules/ext/javatest.jar
+file.reference.tools.jar=${var.platform.home}/lib/tools.jar
+includes=**
+jar.compress=false
+javac.classpath=\
+    ${file.reference.asm-debug-all-6.0_ALPHA.jar}:\
+    ${file.reference.tools.jar}:\
+    ${file.reference.javatest.jar}
+# Space-separated list of extra javac options
+javac.compilerargs=
+javac.deprecation=false
+javac.external.vm=true
+javac.modulepath=
+javac.processorpath=\
+    ${javac.classpath}
+javac.source=1.8
+javac.target=1.8
+javac.test.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}:\
+    ${libs.testng.classpath}
+javac.test.modulepath=\
+    ${javac.modulepath}
+javac.test.processorpath=\
+    ${javac.test.classpath}
+javadoc.additionalparam=
+javadoc.author=false
+javadoc.encoding=${source.encoding}
+javadoc.noindex=false
+javadoc.nonavbar=false
+javadoc.notree=false
+javadoc.private=false
+javadoc.splitindex=true
+javadoc.use=true
+javadoc.version=false
+javadoc.windowtitle=
+main.class=
+manifest.file=manifest.mf
+meta.inf.dir=${src.dir}/META-INF
+mkdist.disabled=false
+platform.active=default_platform
+run.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}
+# Space-separated list of JVM arguments used when running the project.
+# You may also define separate properties like run-sys-prop.name=value instead of -Dname=value.
+# To set system properties for unit tests define test-sys-prop.name=value:
+run.jvmargs=
+run.modulepath=\
+    ${javac.modulepath}
+run.test.classpath=\
+    ${javac.test.classpath}:\
+    ${build.test.classes.dir}
+run.test.modulepath=\
+    ${javac.test.modulepath}
+source.encoding=UTF-8
+src.classes.dir=src/classes
+test.src.dir=test
diff --git a/nbproject/project.xml b/nbproject/project.xml
new file mode 100644
--- /dev/null
+++ b/nbproject/project.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://www.netbeans.org/ns/project/1">
+    <type>org.netbeans.modules.java.j2seproject</type>
+    <configuration>
+        <data xmlns="http://www.netbeans.org/ns/j2se-project/3">
+            <name>JCov</name>
+            <source-roots>
+                <root id="src.classes.dir"/>
+            </source-roots>
+            <test-roots>
+                <root id="test.src.dir" name="test"/>
+            </test-roots>
+        </data>
+    </configuration>
+</project>
diff --git a/src/classes/com/sun/tdk/jcov/Agent.java b/src/classes/com/sun/tdk/jcov/Agent.java
--- a/src/classes/com/sun/tdk/jcov/Agent.java
+++ b/src/classes/com/sun/tdk/jcov/Agent.java
@@ -55,6 +55,8 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import com.sun.tdk.jcov.instrument.OverriddenClassWriter;
+
 /**
  * @author Dmitry Fazunenko
  * @author Alexey Fedorchenko
@@ -177,7 +179,7 @@
                     } else {
                         logger.log(Level.INFO, "Try to transform {0}", className);
 
-                        byte[] newBuff = classMorph.morph(classfileBuffer, loader, flushpath);
+                        byte[] newBuff = classMorph.morph(classfileBuffer, OverriddenClassWriter.forClassLoader(loader), flushpath);
                         return newBuff;
                     }
                 } catch (Throwable e) {
diff --git a/src/classes/com/sun/tdk/jcov/Instr.java b/src/classes/com/sun/tdk/jcov/Instr.java
--- a/src/classes/com/sun/tdk/jcov/Instr.java
+++ b/src/classes/com/sun/tdk/jcov/Instr.java
@@ -35,11 +35,21 @@
 import com.sun.tdk.jcov.tools.LoggingFormatter;
 import com.sun.tdk.jcov.tools.OptionDescr;
 import com.sun.tdk.jcov.util.Utils;
+
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.util.function.Supplier;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import com.sun.tdk.jcov.instrument.ClassLookup;
+import com.sun.tdk.jcov.runtime.Collect;
+
 /**
  * <p> A tool to statically instrument classfiles to collect coverage. </p> <p>
  * There are 2 coverage collection modes: static and dynamic. In static mode
@@ -76,8 +86,8 @@
     private boolean recurse;
     private InstrumentationMode mode = InstrumentationMode.BRANCH;
     private AbstractUniversalInstrumenter instrumenter;
-    private ClassMorph morph;
-    private ClassLoader cl = null;
+//    private ClassMorph morph;
+    private ClassLookup cl = null;
     private static final Logger logger;
 
     static {
@@ -165,10 +175,11 @@
     }
 
     public void instrumentFile(String file, File outDir, String includeRTJar, String moduleName) throws IOException {
-        if (morph != null){
-            morph.setCurrentModuleName(moduleName);
-            instrumentFile(new File(file), outDir, includeRTJar);
-        }
+        throw new UnsupportedOperationException();
+//        if (morph != null){
+//            morph.setCurrentModuleName(moduleName);
+//            instrumentFile(new File(file), outDir, includeRTJar);
+//        }
     }
 
     /**
@@ -218,31 +229,47 @@
      * Set default instrumenter
      */
     private void setDefaultInstrumenter() {
+        InstrumentationParams params = new InstrumentationParams(innerinvocations, false, false, gennative, genfield, false, genabstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE, include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, save_beg, save_end)
+                .setInstrumentSynthetic(gensynthetic)
+                .setInstrumentAnonymous(genanonymous)
+                .setInnerInvocations(innerinvocations);
 
-        if (morph == null) {
-            InstrumentationParams params = new InstrumentationParams(innerinvocations, false, false, gennative, genfield, false, genabstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE, include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, save_beg, save_end)
-                    .setInstrumentSynthetic(gensynthetic)
-                    .setInstrumentAnonymous(genanonymous)
-                    .setInnerInvocations(innerinvocations);
+        Supplier<ClassMorph> createMorph = () -> {
             if (subsequentInstr) {
-                morph = new ClassMorph(params, template);
+                return new ClassMorph(params, template);
             } else {
-                morph = new ClassMorph(params, null);
+                return new ClassMorph(params, null);
             }
-        }
+        };
+
         if (instrumenter == null) {
             instrumenter = new AbstractUniversalInstrumenter(true) {
+                private ClassMorph morph;
                 protected byte[] instrument(byte[] classData, int classLen) throws IOException {
                     return morph.morph(classData, cl, flushPath);
                 }
 
                 public void finishWork() {
-                    if (subsequentInstr) {
-                        morph.saveData(MERGE.MERGE); // template should be initialized
-                    } else {
-                        morph.saveData(template, null, MERGE.OVERWRITE); // template should be initialized
+                }
+
+                @Override
+                protected void processClassDir(File dir, File outDir) throws IOException {
+                    ClassMorph oldMorph = morph;
+                    try {
+                        morph = createMorph.get();
+                        super.processClassDir(dir, outDir);
+                        if (subsequentInstr) {
+                            morph.saveData(MERGE.MERGE); // template should be initialized
+                        } else {
+                            morph.saveData(template, null, MERGE.OVERWRITE); // template should be initialized
+                        }
+                    } finally {
+                        morph.destroy();
+                        morph = oldMorph;
                     }
                 }
+
+
             };
         }
     }
@@ -275,13 +302,13 @@
      * @param outTemplate template path
      */
     public void finishWork(String outTemplate) {
-        if (instrumenter != null) {
-            if (subsequentInstr) {
-                morph.saveData(outTemplate, MERGE.MERGE); // template should be initialized
-            } else {
-                morph.saveData(outTemplate, null, MERGE.OVERWRITE); // template should be initialized
-            }
-        }
+//        if (instrumenter != null) {
+//            if (subsequentInstr) {
+//                morph.saveData(outTemplate, MERGE.MERGE); // template should be initialized
+//            } else {
+//                morph.saveData(outTemplate, null, MERGE.OVERWRITE); // template should be initialized
+//            }
+//        }
     }
 
     /**
@@ -455,7 +482,7 @@
         return flushPath;
     }
 
-    public void setClassLoader(ClassLoader cl) {
+    public void setClassLookup(ClassLookup cl) {
         this.cl = cl;
     }
 
@@ -463,8 +490,15 @@
     protected int run() throws Exception {
         Utils.addToClasspath(srcs);
         try {
+            File nextSlotFile = new File(template, "nextslot");
+            if (nextSlotFile.canRead()) {
+                Collect.setSlot(Integer.parseInt(new String(Files.readAllBytes(nextSlotFile.toPath()), "UTF-8")));
+            }
             instrumentFiles(srcs, outDir, include_rt);
             finishWork(template);
+            try (OutputStream out = new FileOutputStream(nextSlotFile)) {
+                out.write(String.valueOf(Collect.slotCount()).getBytes("UTF-8"));
+            }
         } catch (IOException ex) {
             LoggingFormatter.printStackTrace = true;
             throw new Exception("Critical exception: ", ex);
@@ -575,7 +609,7 @@
 
         mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));
         template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);
-        Utils.checkFileNotNull(template, "template filename", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);
+        Utils.checkFileNotNull(template, "template filename", Utils.CheckOptions.FILE_NOTISFILE, Utils.CheckOptions.FILE_PARENTEXISTS);
 
         subsequentInstr = opts.isSet(DSC_SUBSEQUENT);
 
diff --git a/src/classes/com/sun/tdk/jcov/JREInstr.java b/src/classes/com/sun/tdk/jcov/JREInstr.java
--- a/src/classes/com/sun/tdk/jcov/JREInstr.java
+++ b/src/classes/com/sun/tdk/jcov/JREInstr.java
@@ -43,6 +43,8 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import com.sun.tdk.jcov.instrument.ClassLookup;
+
 /**
  * <p> A tool to statically instrument JRE. </p> <p> There are 2 coverage
  * collection modes: static and dynamic. In static mode JCov reads and modifies
@@ -100,320 +102,333 @@
 
     @Override
     protected int run() throws Exception {
-        final String[] toInstr = new String[]{toInstrument.getAbsolutePath()};
-        Utils.addToClasspath(toInstr);
+//        final String[] toInstr = new String[]{toInstrument.getAbsolutePath()};
+//        Utils.addToClasspath(toInstr);
         instr.startWorking();
 
-        StaticJREInstrClassLoader cl = new StaticJREInstrClassLoader(new URL[]{toInstrument.toURI().toURL()});
-        instr.setClassLoader(cl);
+        ClassLookup cl = new ClassLookup() {
+            public InputStream findClass(String name) {
+                File resource = new File(name + ".class");
 
-        if (toInstrument.getName().equals("jmods")) {
-            logger.log(Level.INFO, "working with jmods");
-            File jdk = new File(toInstrument.getParentFile(), "jdk");
-            if (!jdk.exists()) {
-                jdk = toInstrument.getParentFile();
-            }
-            File jmodsTemp = new File(toInstrument.getParentFile(), "jmod_temp");
-
-            for (File mod : toInstrument.listFiles()) {
-                File jmodDir = extractJMod(jdk, mod.getAbsoluteFile(), jmodsTemp);
-                Utils.addToClasspath(new String[]{new File(jmodDir, "classes").getAbsolutePath()});
-            }
-
-            try {
-                for (File mod : jmodsTemp.listFiles()) {
-                    if (mod != null && mod.isDirectory()) {
-
-                        File modClasses = new File(mod, "classes");
-                        if ("java.base".equals(mod.getName())) {
-                            updateExports(new File(modClasses, "module-info.class"), cl);
-                        } else {
-                            updateHashes(new File(modClasses, "module-info.class"), cl);
-                        }
-
-                        instr.instrumentFile(modClasses.getAbsolutePath(), null, null, mod.getName());
-                        createJMod(mod, jdk, implant.getAbsolutePath());
+                if (resource.canRead()) {
+                    try {
+                        return new FileInputStream(resource);
+                    } catch (FileNotFoundException ex) {
+                        return null;
                     }
                 }
+                return null;
+            }
+        };
+        instr.setClassLookup(cl);
 
-                File newJdkDir = runJLink(jmodsTemp, jdk);
-                if (newJdkDir != null) {
-                    String jimage_path = File.separator + "lib" + File.separator + "modules" + File.separator + "bootmodules.jimage";
-                    File orig_jimage = new File(jdk.getCanonicalPath() + jimage_path);
-                    File instr_jimage = new File(newJdkDir.getCanonicalPath() + jimage_path);
-
-                    if (!orig_jimage.exists()) {
-                        jimage_path = File.separator + "lib" + File.separator + "modules";
-                        orig_jimage = new File(jdk.getCanonicalPath() + jimage_path);
-                        instr_jimage = new File(newJdkDir.getCanonicalPath() + jimage_path);
-                    }
-                    Utils.copyFile(orig_jimage, new File(orig_jimage.getParent(), orig_jimage.getName() + ".bak"));
-
-                    if (!orig_jimage.delete()) {
-                        Utils.copyFile(instr_jimage, new File(orig_jimage.getParent(), orig_jimage.getName() + ".instr"));
-                        logger.log(Level.SEVERE, "please, delete original jimage manually: " + orig_jimage);
-                    } else {
-                        Utils.copyFile(instr_jimage, orig_jimage);
-                    }
-                    if (!Utils.deleteDirectory(newJdkDir)) {
-                        logger.log(Level.SEVERE, "please, delete " + newJdkDir + " new instumented jdk dir manually");
-                    }
-                    if (!Utils.deleteDirectory(jmodsTemp)) {
-                        logger.log(Level.SEVERE, "please, delete " + jmodsTemp + " temp jmod dir manually");
-                    }
-
-                } else {
-                    logger.log(Level.SEVERE, "failed to link modules. Please, run jlink for " + jmodsTemp + " temp jmod dir manually");
-                }
-            } catch (Exception e) {
-                logger.log(Level.SEVERE, "exception while creating mods, e = " + e);
-            }
-        } else if (toInstrument.getAbsolutePath().endsWith("bootmodules.jimage")) {
-            ArrayList<File> jdkImages = new ArrayList<File>();
-            jdkImages.add(toInstrument);
-            if (addJimages != null) {
-                Collections.addAll(jdkImages, addJimages);
-            }
-
-            for (File jimageInstr : jdkImages) {
-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(".jimage"));
-
-                expandJimage(jimageInstr, tempDirName);
-
-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);
-                //still need it
-                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});
-                for (File file : dirtoInstrument.listFiles()) {
-                    if (file.isDirectory()) {
-                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});
-                    }
-                }
-
-                if (jimageInstr.equals(toInstrument)) {
-                    for (File mod : dirtoInstrument.listFiles()) {
-                        if (mod != null && mod.isDirectory()) {
-
-                            if ("java.base".equals(mod.getName())) {
-                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());
-                            } else {
-                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());
-                            }
-                        }
-                    }
-                } else {
-                    for (File mod : dirtoInstrument.listFiles()) {
-                        if (mod != null && mod.isDirectory()) {
-                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());
-                        }
-                    }
-                }
-                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + "i");
-
-            }
-            for (File jimageInstr : jdkImages) {
-
-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(".jimage"));
-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);
-                if (!Utils.deleteDirectory(dirtoInstrument)) {
-                    logger.log(Level.SEVERE, "please, delete " + tempDirName + " jimage dir manually");
-                }
-
-                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + ".bak"));
-
-                if (!jimageInstr.delete()) {
-                    logger.log(Level.SEVERE, "please, delete original jimage manually: " + jimageInstr);
-                } else {
-                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + "i"), jimageInstr);
-                    new File(jimageInstr.getAbsolutePath() + "i").delete();
-                }
-
-            }
-
-        } else {
-            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());
-        }
-
-        ArrayList<String> srcs = null;
-        if (addJars != null) {
-            srcs = new ArrayList<String>();
-            for (int i = 0; i < addJars.length; ++i) {
-                srcs.add(addJars[i].getAbsolutePath());
-            }
-        }
-
-        if (addTests != null) {
-            if (srcs == null) {
-                srcs = new ArrayList<String>();
-            }
-            for (int i = 0; i < addTests.length; ++i) {
-                srcs.add(addTests[i].getAbsolutePath());
-            }
-        }
-
-        if (srcs != null) {
-            Utils.addToClasspath(srcs.toArray(new String[0]));
-            instr.instrumentFiles(srcs.toArray(new String[0]), null, null);
-        }
-        instr.finishWork();
+//        if (toInstrument.getName().equals("jmods")) {
+//            logger.log(Level.INFO, "working with jmods");
+//            File jdk = new File(toInstrument.getParentFile(), "jdk");
+//            if (!jdk.exists()) {
+//                jdk = toInstrument.getParentFile();
+//            }
+//            File jmodsTemp = new File(toInstrument.getParentFile(), "jmod_temp");
+//
+//            for (File mod : toInstrument.listFiles()) {
+//                File jmodDir = extractJMod(jdk, mod.getAbsoluteFile(), jmodsTemp);
+//                Utils.addToClasspath(new String[]{new File(jmodDir, "classes").getAbsolutePath()});
+//            }
+//
+//            try {
+//                for (File mod : jmodsTemp.listFiles()) {
+//                    if (mod != null && mod.isDirectory()) {
+//
+//                        File modClasses = new File(mod, "classes");
+//                        if ("java.base".equals(mod.getName())) {
+//                            updateExports(new File(modClasses, "module-info.class"), cl);
+//                        } else {
+//                            updateHashes(new File(modClasses, "module-info.class"), cl);
+//                        }
+//
+//                        instr.instrumentFile(modClasses.getAbsolutePath(), null, null, mod.getName());
+//                        createJMod(mod, jdk, implant.getAbsolutePath());
+//                    }
+//                }
+//
+//                File newJdkDir = runJLink(jmodsTemp, jdk);
+//                if (newJdkDir != null) {
+//                    String jimage_path = File.separator + "lib" + File.separator + "modules" + File.separator + "bootmodules.jimage";
+//                    File orig_jimage = new File(jdk.getCanonicalPath() + jimage_path);
+//                    File instr_jimage = new File(newJdkDir.getCanonicalPath() + jimage_path);
+//
+//                    if (!orig_jimage.exists()) {
+//                        jimage_path = File.separator + "lib" + File.separator + "modules";
+//                        orig_jimage = new File(jdk.getCanonicalPath() + jimage_path);
+//                        instr_jimage = new File(newJdkDir.getCanonicalPath() + jimage_path);
+//                    }
+//                    Utils.copyFile(orig_jimage, new File(orig_jimage.getParent(), orig_jimage.getName() + ".bak"));
+//
+//                    if (!orig_jimage.delete()) {
+//                        Utils.copyFile(instr_jimage, new File(orig_jimage.getParent(), orig_jimage.getName() + ".instr"));
+//                        logger.log(Level.SEVERE, "please, delete original jimage manually: " + orig_jimage);
+//                    } else {
+//                        Utils.copyFile(instr_jimage, orig_jimage);
+//                    }
+//                    if (!Utils.deleteDirectory(newJdkDir)) {
+//                        logger.log(Level.SEVERE, "please, delete " + newJdkDir + " new instumented jdk dir manually");
+//                    }
+//                    if (!Utils.deleteDirectory(jmodsTemp)) {
+//                        logger.log(Level.SEVERE, "please, delete " + jmodsTemp + " temp jmod dir manually");
+//                    }
+//
+//                } else {
+//                    logger.log(Level.SEVERE, "failed to link modules. Please, run jlink for " + jmodsTemp + " temp jmod dir manually");
+//                }
+//            } catch (Exception e) {
+//                logger.log(Level.SEVERE, "exception while creating mods, e = " + e);
+//            }
+//        } else if (toInstrument.getAbsolutePath().endsWith("bootmodules.jimage")) {
+//            ArrayList<File> jdkImages = new ArrayList<File>();
+//            jdkImages.add(toInstrument);
+//            if (addJimages != null) {
+//                Collections.addAll(jdkImages, addJimages);
+//            }
+//
+//            for (File jimageInstr : jdkImages) {
+//                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(".jimage"));
+//
+//                expandJimage(jimageInstr, tempDirName);
+//
+//                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);
+//                //still need it
+//                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});
+//                for (File file : dirtoInstrument.listFiles()) {
+//                    if (file.isDirectory()) {
+//                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});
+//                    }
+//                }
+//
+//                if (jimageInstr.equals(toInstrument)) {
+//                    for (File mod : dirtoInstrument.listFiles()) {
+//                        if (mod != null && mod.isDirectory()) {
+//
+//                            if ("java.base".equals(mod.getName())) {
+//                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());
+//                            } else {
+//                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());
+//                            }
+//                        }
+//                    }
+//                } else {
+//                    for (File mod : dirtoInstrument.listFiles()) {
+//                        if (mod != null && mod.isDirectory()) {
+//                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());
+//                        }
+//                    }
+//                }
+//                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + "i");
+//
+//            }
+//            for (File jimageInstr : jdkImages) {
+//
+//                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(".jimage"));
+//                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);
+//                if (!Utils.deleteDirectory(dirtoInstrument)) {
+//                    logger.log(Level.SEVERE, "please, delete " + tempDirName + " jimage dir manually");
+//                }
+//
+//                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + ".bak"));
+//
+//                if (!jimageInstr.delete()) {
+//                    logger.log(Level.SEVERE, "please, delete original jimage manually: " + jimageInstr);
+//                } else {
+//                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + "i"), jimageInstr);
+//                    new File(jimageInstr.getAbsolutePath() + "i").delete();
+//                }
+//
+//            }
+//
+//        } else {
+//            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());
+//        }
+//
+//        ArrayList<String> srcs = null;
+//        if (addJars != null) {
+//            srcs = new ArrayList<String>();
+//            for (int i = 0; i < addJars.length; ++i) {
+//                srcs.add(addJars[i].getAbsolutePath());
+//            }
+//        }
+//
+//        if (addTests != null) {
+//            if (srcs == null) {
+//                srcs = new ArrayList<String>();
+//            }
+//            for (int i = 0; i < addTests.length; ++i) {
+//                srcs.add(addTests[i].getAbsolutePath());
+//            }
+//        }
+//
+//        if (srcs != null) {
+//            Utils.addToClasspath(srcs.toArray(new String[0]));
+//            instr.instrumentFiles(srcs.toArray(new String[0]), null, null);
+//        }
+//        instr.finishWork();
         return SUCCESS_EXIT_CODE;
     }
 
 
-    private void updateExports(File file, ClassLoader cl) {
-        try {
-            InputStream in = new FileInputStream(file.getCanonicalPath());
-            ClassReader cr = new ClassReader(in);
-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);
-            cr.accept(cw, new Attribute[]{new ConcealedPackagesAttribute(), new ModuleAttribute()}, 0);
-
-            DataOutputStream dout = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));
-            dout.write(cw.toByteArray());
-            dout.flush();
-            in.close();
-            dout.close();
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "can not update module exports", e);
-        }
-    }
-
-    private void updateHashes(File file, ClassLoader cl) {
-        try {
-            InputStream in = new FileInputStream(file.getCanonicalPath());
-            ClassReader cr = new ClassReader(in);
-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);
-            cr.accept(cw, new Attribute[]{new ConcealedPackagesAttribute(), new HashesAttribute()}, 0);
-
-            DataOutputStream doutn = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));
-            doutn.write(cw.toByteArray());
-            doutn.flush();
-            in.close();
-            doutn.close();
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "can not update module hashes", e);
-        }
-    }
-
-    private File extractJMod(File jdk, File from, File to) {
-        try {
-            String name = from.getName();
-            if (name.contains(".jmod")) {
-                name = name.substring(0, name.indexOf(".jmod"));
-            }
-            File modDir = new File(to, name);
-            modDir.mkdirs();
-
-            String command = jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jar xf " + from.getAbsolutePath();
-            Process process = Runtime.getRuntime().exec(command, null, modDir);
-            process.waitFor();
-            if (process.exitValue() != 0) {
-                logger.log(Level.SEVERE, "wrong command for unjar jmod: " + command);
-                return null;
-            }
-            return modDir;
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "exception in process(unjar jmod)", e);
-            return null;
-        }
-    }
-
-    private File runJLink(File jmodDir, File jdk) {
-        try {
-
-            String command = jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jlink --modulepath " + jmodDir.getCanonicalPath() + " --addmods ";
-
-            StringBuilder sb = new StringBuilder("");
-            for (File subDir : jmodDir.listFiles()) {
-                if (subDir.isDirectory()) {
-                    sb.append(subDir.getName()).append(",");
-                }
-            }
-            String mods = sb.toString().substring(0, sb.toString().length() - 1);
-            command += mods + " --output instr_jimage_dir";
-
-            Process process = Runtime.getRuntime().exec(command, null, jmodDir.getParentFile());
-            process.waitFor();
-            if (process.exitValue() != 0) {
-                logger.log(Level.SEVERE, "wrong command for jlink mods: " + command);
-                return null;
-            }
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "exception in process(jlink mods)", e);
-            return null;
-        }
-
-        return new File(jmodDir.getParentFile(), "instr_jimage_dir");
-    }
-
-    private void createJMod(File jmodDir, File jdk, String rt_path) {
-        try {
-            File modsDir = jmodDir.getParentFile();
-            StringBuilder command = new StringBuilder();
-            command.append(jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jmod --create ");
-            command.append("--modulepath " + modsDir.getCanonicalPath() + " ");
-
-            for (File subDir : jmodDir.listFiles()) {
-                if (subDir.getName().equals("classes")) {
-                    if ("java.base".equals(jmodDir.getName())) {
-                        command.append("--class-path " + rt_path + File.pathSeparator + jmodDir.getName() + File.separator + "classes ");
-                    } else {
-                        command.append("--class-path " + jmodDir.getName() + File.separator + "classes ");
-                    }
-                }
-                if (subDir.getName().equals("bin")) {
-                    command.append("--cmds " + jmodDir.getName() + File.separator + "bin ");
-                }
-                if (subDir.getName().equals("conf")) {
-                    command.append("--config " + jmodDir.getName() + File.separator + "conf ");
-                }
-                if (subDir.getName().equals("native")) {
-                    command.append("--libs " + jmodDir.getName() + File.separator + "native ");
-                }
-            }
-            command.append(" " + jmodDir.getName() + ".jmod");
-
-            Process process = Runtime.getRuntime().exec(command.toString(), null, modsDir);
-            process.waitFor();
-            if (process.exitValue() != 0) {
-                logger.log(Level.SEVERE, "wrong command for create jmod: " + command.toString());
-            }
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "exception in process(create jmod)", e);
-        }
-    }
-
-    private boolean expandJimage(File jimage, String tempDirName) {
-        try {
-            String command = jimage.getParentFile().getParentFile().getParent() + File.separator + "bin" + File.separator + "jimage extract --dir " +
-                    jimage.getParent() + File.separator + tempDirName + " " + jimage.getAbsolutePath();
-            Process process = Runtime.getRuntime().exec(command);
-            process.waitFor();
-            if (process.exitValue() != 0) {
-                logger.log(Level.SEVERE, "wrong command for expand jimage: " + command);
-                return false;
-            }
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "exception in process(expanding jimage)", e);
-            return false;
-        }
-        return true;
-    }
-
-    private boolean createJimage(File dir, String new_jimage_path) {
-        try {
-            String command = dir.getParentFile().getParentFile().getParent() + File.separator + "bin" + File.separator + "jimage recreate --dir " +
-                    dir + " " + new_jimage_path;
-            Process process = Runtime.getRuntime().exec(command);
-            process.waitFor();
-            if (process.exitValue() != 0) {
-                logger.log(Level.SEVERE, "wrong command for create jimage: " + command);
-                return false;
-            }
-        } catch (Exception e) {
-            logger.log(Level.SEVERE, "exception in process(expanding jimage)", e);
-            return false;
-        }
-        return true;
-    }
+//    private void updateExports(File file, ClassLoader cl) {
+//        try {
+//            InputStream in = new FileInputStream(file.getCanonicalPath());
+//            ClassReader cr = new ClassReader(in);
+//            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);
+//            cr.accept(cw, new Attribute[]{new ConcealedPackagesAttribute(), new ModuleAttribute()}, 0);
+//
+//            DataOutputStream dout = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));
+//            dout.write(cw.toByteArray());
+//            dout.flush();
+//            in.close();
+//            dout.close();
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "can not update module exports", e);
+//        }
+//    }
+//
+//    private void updateHashes(File file, ClassLoader cl) {
+//        try {
+//            InputStream in = new FileInputStream(file.getCanonicalPath());
+//            ClassReader cr = new ClassReader(in);
+//            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);
+//            cr.accept(cw, new Attribute[]{new ConcealedPackagesAttribute(), new HashesAttribute()}, 0);
+//
+//            DataOutputStream doutn = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));
+//            doutn.write(cw.toByteArray());
+//            doutn.flush();
+//            in.close();
+//            doutn.close();
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "can not update module hashes", e);
+//        }
+//    }
+//
+//    private File extractJMod(File jdk, File from, File to) {
+//        try {
+//            String name = from.getName();
+//            if (name.contains(".jmod")) {
+//                name = name.substring(0, name.indexOf(".jmod"));
+//            }
+//            File modDir = new File(to, name);
+//            modDir.mkdirs();
+//
+//            String command = jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jar xf " + from.getAbsolutePath();
+//            Process process = Runtime.getRuntime().exec(command, null, modDir);
+//            process.waitFor();
+//            if (process.exitValue() != 0) {
+//                logger.log(Level.SEVERE, "wrong command for unjar jmod: " + command);
+//                return null;
+//            }
+//            return modDir;
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "exception in process(unjar jmod)", e);
+//            return null;
+//        }
+//    }
+//
+//    private File runJLink(File jmodDir, File jdk) {
+//        try {
+//
+//            String command = jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jlink --modulepath " + jmodDir.getCanonicalPath() + " --addmods ";
+//
+//            StringBuilder sb = new StringBuilder("");
+//            for (File subDir : jmodDir.listFiles()) {
+//                if (subDir.isDirectory()) {
+//                    sb.append(subDir.getName()).append(",");
+//                }
+//            }
+//            String mods = sb.toString().substring(0, sb.toString().length() - 1);
+//            command += mods + " --output instr_jimage_dir";
+//
+//            Process process = Runtime.getRuntime().exec(command, null, jmodDir.getParentFile());
+//            process.waitFor();
+//            if (process.exitValue() != 0) {
+//                logger.log(Level.SEVERE, "wrong command for jlink mods: " + command);
+//                return null;
+//            }
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "exception in process(jlink mods)", e);
+//            return null;
+//        }
+//
+//        return new File(jmodDir.getParentFile(), "instr_jimage_dir");
+//    }
+//
+//    private void createJMod(File jmodDir, File jdk, String rt_path) {
+//        try {
+//            File modsDir = jmodDir.getParentFile();
+//            StringBuilder command = new StringBuilder();
+//            command.append(jdk.getAbsolutePath() + File.separator + "bin" + File.separator + "jmod --create ");
+//            command.append("--modulepath " + modsDir.getCanonicalPath() + " ");
+//
+//            for (File subDir : jmodDir.listFiles()) {
+//                if (subDir.getName().equals("classes")) {
+//                    if ("java.base".equals(jmodDir.getName())) {
+//                        command.append("--class-path " + rt_path + File.pathSeparator + jmodDir.getName() + File.separator + "classes ");
+//                    } else {
+//                        command.append("--class-path " + jmodDir.getName() + File.separator + "classes ");
+//                    }
+//                }
+//                if (subDir.getName().equals("bin")) {
+//                    command.append("--cmds " + jmodDir.getName() + File.separator + "bin ");
+//                }
+//                if (subDir.getName().equals("conf")) {
+//                    command.append("--config " + jmodDir.getName() + File.separator + "conf ");
+//                }
+//                if (subDir.getName().equals("native")) {
+//                    command.append("--libs " + jmodDir.getName() + File.separator + "native ");
+//                }
+//            }
+//            command.append(" " + jmodDir.getName() + ".jmod");
+//
+//            Process process = Runtime.getRuntime().exec(command.toString(), null, modsDir);
+//            process.waitFor();
+//            if (process.exitValue() != 0) {
+//                logger.log(Level.SEVERE, "wrong command for create jmod: " + command.toString());
+//            }
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "exception in process(create jmod)", e);
+//        }
+//    }
+//
+//    private boolean expandJimage(File jimage, String tempDirName) {
+//        try {
+//            String command = jimage.getParentFile().getParentFile().getParent() + File.separator + "bin" + File.separator + "jimage extract --dir " +
+//                    jimage.getParent() + File.separator + tempDirName + " " + jimage.getAbsolutePath();
+//            Process process = Runtime.getRuntime().exec(command);
+//            process.waitFor();
+//            if (process.exitValue() != 0) {
+//                logger.log(Level.SEVERE, "wrong command for expand jimage: " + command);
+//                return false;
+//            }
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "exception in process(expanding jimage)", e);
+//            return false;
+//        }
+//        return true;
+//    }
+//
+//    private boolean createJimage(File dir, String new_jimage_path) {
+//        try {
+//            String command = dir.getParentFile().getParentFile().getParent() + File.separator + "bin" + File.separator + "jimage recreate --dir " +
+//                    dir + " " + new_jimage_path;
+//            Process process = Runtime.getRuntime().exec(command);
+//            process.waitFor();
+//            if (process.exitValue() != 0) {
+//                logger.log(Level.SEVERE, "wrong command for create jimage: " + command);
+//                return false;
+//            }
+//        } catch (Exception e) {
+//            logger.log(Level.SEVERE, "exception in process(expanding jimage)", e);
+//            return false;
+//        }
+//        return true;
+//    }
 
     @Override
     protected EnvHandler defineHandler() {
diff --git a/src/classes/com/sun/tdk/jcov/insert/AbstractUniversalInstrumenter.java b/src/classes/com/sun/tdk/jcov/insert/AbstractUniversalInstrumenter.java
--- a/src/classes/com/sun/tdk/jcov/insert/AbstractUniversalInstrumenter.java
+++ b/src/classes/com/sun/tdk/jcov/insert/AbstractUniversalInstrumenter.java
@@ -159,6 +159,9 @@
             return true;
         }
 
+        if (outFile.lastModified() >= f.lastModified())
+            return true; //already done   //TODO: expects that all classfiles originating in the same source are changed at once/synchronously
+
         ensureClassBufLength(classLength, false);
         FileInputStream fis = null;
 
diff --git a/src/classes/com/sun/tdk/jcov/instrument/BranchCodeMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/BranchCodeMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/BranchCodeMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/BranchCodeMethodAdapter.java
@@ -420,7 +420,7 @@
             prev = curr;
         }
         // System.out.println("ei: " + ei + " / " + exits.size());
-        assert (ei == exits.size());
+//        assert (ei == exits.size());
     }
 
     private void insertInstrumentation() {
@@ -477,7 +477,7 @@
                 instructions.insertBefore(insn, realStuff);
             }
 
-            assert (remaining == 0);
+//            assert (remaining == 0);
         }
     }
 
diff --git a/src/classes/com/sun/tdk/jcov/instrument/ClassLookup.java b/src/classes/com/sun/tdk/jcov/instrument/ClassLookup.java
new file mode 100644
--- /dev/null
+++ b/src/classes/com/sun/tdk/jcov/instrument/ClassLookup.java
@@ -0,0 +1,7 @@
+package com.sun.tdk.jcov.instrument;
+
+import java.io.InputStream;
+
+    public interface ClassLookup {
+        public InputStream findClass(String name);
+    }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/ClassMorph.java b/src/classes/com/sun/tdk/jcov/instrument/ClassMorph.java
--- a/src/classes/com/sun/tdk/jcov/instrument/ClassMorph.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/ClassMorph.java
@@ -45,6 +45,9 @@
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.util.TraceClassVisitor;
 
+import com.sun.tdk.jcov.instrument.OverriddenClassWriter;
+import com.sun.tdk.jcov.instrument.ClassLookup;
+
 /**
  * @author Dmitry Fazunenko
  * @author Alexey Fedorchenko
@@ -130,9 +133,9 @@
      * @return
      * @throws IOException
      */
-    public byte[] morph(byte[] classfileBuffer, ClassLoader loader, String flushPath) throws IOException {
-        if (loader == null) {
-            loader = ClassLoader.getSystemClassLoader();
+    public byte[] morph(byte[] classfileBuffer, ClassLookup classLookup, String flushPath) throws IOException {
+        if (classLookup == null) {
+            classLookup = OverriddenClassWriter.DEFAULT_CLASS_LOOKUP;
         }
 
         if (classfileBuffer[0] != -54 || classfileBuffer[1] != -2 || classfileBuffer[2] != -70 || classfileBuffer[3] != -66) {
@@ -186,7 +189,7 @@
             // even those classes which are out of scope require some minor
             // transformation
 
-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_MAXS, loader);
+            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_MAXS, classLookup);
             ClassVisitor cv = shouldFlush ? new TraceClassVisitor(cw, DebugUtils.getPrintWriter(fullname, flushPath))
                     : cw;
             cv = new InvokeClassAdapter(cv, params);
@@ -241,7 +244,7 @@
             opt = ClassWriter.COMPUTE_FRAMES;
         }
 
-        ClassWriter cw = new OverriddenClassWriter(cr, opt, loader);
+        ClassWriter cw = new OverriddenClassWriter(cr, opt, classLookup);
         DataClass k = new DataClass(root.rootId(), fullname, moduleName.substring(7), checksum, false);
 //        ClassVisitor cv = shouldFlush ? new TraceClassVisitor
 //                (cw, DebugUtils.getPrintWriter(fullname, Options.getFlushPath())) :
@@ -607,4 +610,8 @@
                 || fullname.startsWith("sun")
                 || fullname.startsWith("java/util");
     }
+
+    public void destroy() {
+        root.destroy();
+    }
 }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/DataRoot.java b/src/classes/com/sun/tdk/jcov/instrument/DataRoot.java
--- a/src/classes/com/sun/tdk/jcov/instrument/DataRoot.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/DataRoot.java
@@ -1318,11 +1318,11 @@
         }
     }
 
-    private static DataRoot mapXML(InputStream is, long[] counts) throws Exception {
-        DataRoot root = Reader.readXML(is);
-        root = applyCounts(root, counts, true);
-        return root;
-    }
+//    private static DataRoot mapXML(InputStream is, long[] counts) throws Exception {
+//        DataRoot root = Reader.readXML(is);
+//        root = applyCounts(root, counts, true);
+//        return root;
+//    }
 
     public static DataRoot setCounts(DataRoot root, long[] counts) throws Exception {
         return applyCounts(root, counts, false);
diff --git a/src/classes/com/sun/tdk/jcov/instrument/DeferringMethodClassAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/DeferringMethodClassAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/DeferringMethodClassAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/DeferringMethodClassAdapter.java
@@ -44,7 +44,7 @@
     private final InstrumentationParams params;
 
     public DeferringMethodClassAdapter(final ClassVisitor cv, DataClass k, InstrumentationParams params) {
-        super(ASM4, cv);
+        super(ASM5, cv);
         this.k = k;
         this.params = params;
     }
@@ -168,7 +168,7 @@
         MethodVisitor mv = visitMethodCoverage(access, name, desc, signature, exceptions);
 
         if ("<clinit>".equals(name) && !params.isDynamicCollect() && (k.getPackageName().startsWith("java/lang/"))) {
-            mv = new MethodVisitor(Opcodes.ASM4, mv) {
+            mv = new MethodVisitor(Opcodes.ASM5, mv) {
                 public void visitCode() {
                     mv.visitMethodInsn(INVOKESTATIC, "com/sun/tdk/jcov/runtime/Collect", "init", "()V");
                     super.visitCode();
@@ -204,7 +204,7 @@
         if (params.isDataSaveFilterAccept(k.getFullname(), name, false)) {
             mv = new SavePointsMethodAdapter(mv, false);
         }
-        mv = new MethodVisitor(Opcodes.ASM4, mv) {
+        mv = new MethodVisitor(Opcodes.ASM5, mv) {
             @Override
             public void visitLocalVariable(String arg0, String arg1, String arg2, Label arg3, Label arg4, int arg5) {
                 //super.visitLocalVariable(arg0, arg1, arg2, arg3, arg4, arg5);
diff --git a/src/classes/com/sun/tdk/jcov/instrument/EntryCodeMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/EntryCodeMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/EntryCodeMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/EntryCodeMethodAdapter.java
@@ -43,7 +43,7 @@
     EntryCodeMethodAdapter(final MethodVisitor mv,
             final DataMethodEntryOnly method,
             final InstrumentationParams params) {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         this.method = method;
         this.params = params;
     }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/FieldAnnotationVisitor.java b/src/classes/com/sun/tdk/jcov/instrument/FieldAnnotationVisitor.java
--- a/src/classes/com/sun/tdk/jcov/instrument/FieldAnnotationVisitor.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/FieldAnnotationVisitor.java
@@ -40,7 +40,7 @@
     final FieldVisitor fv;
 
     FieldAnnotationVisitor(final FieldVisitor fv, final DataField field) {
-        super(Opcodes.ASM4, fv);
+        super(Opcodes.ASM5, fv);
         this.fv = fv;
         this.field = field;
     }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/ForkingMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/ForkingMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/ForkingMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/ForkingMethodAdapter.java
@@ -44,7 +44,7 @@
         final AnnotationVisitor av2;
 
         DuplicatingAnnotationAdapter(final AnnotationVisitor av1, final AnnotationVisitor av2) {
-            super(Opcodes.ASM4);
+            super(Opcodes.ASM5);
             this.av1 = av1;
             this.av2 = av2;
         }
@@ -88,7 +88,7 @@
      * @param mv the code visitor to which this adapter must delegate calls.
      */
     public ForkingMethodAdapter(final MethodVisitor mv1, final MethodVisitor mv2) {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
         this.mv1 = mv1;
         this.mv2 = mv2;
     }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/InstrumentedAttributeClassAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/InstrumentedAttributeClassAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/InstrumentedAttributeClassAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/InstrumentedAttributeClassAdapter.java
@@ -45,7 +45,7 @@
     }
 
     public InstrumentedAttributeClassAdapter(final ClassVisitor cv) {
-        super(Opcodes.ASM4, cv);
+        super(Opcodes.ASM5, cv);
     }
 
     public void visitAttribute(Attribute attr) {
diff --git a/src/classes/com/sun/tdk/jcov/instrument/InvokeClassAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/InvokeClassAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/InvokeClassAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/InvokeClassAdapter.java
@@ -38,7 +38,7 @@
     private final InstrumentationParams params;
 
     public InvokeClassAdapter(final ClassVisitor cv, final InstrumentationParams params) {
-        super(Opcodes.ASM4, cv);
+        super(Opcodes.ASM5, cv);
         this.params = params;
     }
 
diff --git a/src/classes/com/sun/tdk/jcov/instrument/InvokeMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/InvokeMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/InvokeMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/InvokeMethodAdapter.java
@@ -70,7 +70,7 @@
             Collections.synchronizedMap(new HashMap<String, Integer>());
 
     public InvokeMethodAdapter(MethodVisitor mv, String className, final InstrumentationParams params) {
-        super(ASM4, mv);
+        super(ASM5, mv);
         this.className = className;
         this.params = params;
     }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/MethodAnnotationAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/MethodAnnotationAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/MethodAnnotationAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/MethodAnnotationAdapter.java
@@ -45,7 +45,7 @@
 
     MethodAnnotationAdapter(final MethodVisitor mv,
             final DataMethod method) {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         this.meth = method;
     }
 }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/OffsetRecordingMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/OffsetRecordingMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/OffsetRecordingMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/OffsetRecordingMethodAdapter.java
@@ -45,7 +45,7 @@
 
     public OffsetRecordingMethodAdapter(final MethodVisitor mv,
             final DataMethodWithBlocks method) {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         this.currentInstructionIndex = 0;
         this.bcis = new int[60];
         this.method = method;
@@ -99,13 +99,10 @@
         super.visitFieldInsn(opcode, owner, name, desc);
     }
 
-    public void visitMethodInsn(
-            final int opcode,
-            final String owner,
-            final String name,
-            final String desc) {
+    @Override
+    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
         recordInstructionOffset();
-        super.visitMethodInsn(opcode, owner, name, desc);
+        super.visitMethodInsn(opcode, owner, name, desc, itf);
     }
 
     public void visitJumpInsn(final int opcode, final Label label) {
diff --git a/src/classes/com/sun/tdk/jcov/instrument/OverriddenClassWriter.java b/src/classes/com/sun/tdk/jcov/instrument/OverriddenClassWriter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/OverriddenClassWriter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/OverriddenClassWriter.java
@@ -24,7 +24,6 @@
  */
 package com.sun.tdk.jcov.instrument;
 
-import com.sun.tdk.jcov.JREInstr;
 import com.sun.tdk.jcov.runtime.PropertyFinder;
 import java.io.IOException;
 import java.io.InputStream;
@@ -47,12 +46,12 @@
  */
 public class OverriddenClassWriter extends ClassWriter {
 
-    private final ClassLoader loader;
+    private final ClassLookup classLookup;
     private static String[] customExtentions = PropertyFinder.findValue("clext", "").split(":");
 
-    public OverriddenClassWriter(final ClassReader classReader, final int flags, ClassLoader loader) {
+    public OverriddenClassWriter(final ClassReader classReader, final int flags, ClassLookup classLookup) {
         super(classReader, flags);
-        this.loader = loader;
+        this.classLookup = classLookup;
     }
 
     /**
@@ -64,17 +63,17 @@
      */
     @Override
     protected String getCommonSuperClass(final String type1, final String type2) {
-        return getCommonSuperClassAlt(type1, type2, loader);
+        return getCommonSuperClassAlt(type1, type2, classLookup);
     }
 
-    static String getCommonSuperClassAlt(final String type1, final String type2, ClassLoader loader) {
-        if (isAssignableFrom(type2, type1, loader)) {
+    static String getCommonSuperClassAlt(final String type1, final String type2, ClassLookup classLookup) {
+        if (isAssignableFrom(type2, type1, classLookup)) {
             return type2;
         }
 
         String type = type1;
-        while (!isAssignableFrom(type, type2, loader)) {
-            type = getSuperClass(type, loader);
+        while (!isAssignableFrom(type, type2, classLookup)) {
+            type = getSuperClass(type, classLookup);
         }
         return type;
     }
@@ -106,7 +105,7 @@
      *
      * @return true if type t1 is assignable from t2.
      */
-    public static boolean isAssignableFrom(String t1, String t2, final ClassLoader loader) {
+    public static boolean isAssignableFrom(String t1, String t2, final ClassLookup classLookup) {
         if (t1 == null) {
             throw new RuntimeException("Can't read superclass bytecode. Please add it to the classpath. ");
         }
@@ -118,7 +117,7 @@
             return false;
         }
 
-        String superType = getSuperClass(t2, loader); // init interfaces for t2!
+        String superType = getSuperClass(t2, classLookup); // init interfaces for t2!
         List<String> t2Interfaces = class_interfaces.get(t2);
         if (t2Interfaces != null && !t2Interfaces.isEmpty()) {
             for (String in2 : t2Interfaces) {
@@ -128,7 +127,7 @@
             }
         }
 
-        return isAssignableFrom(t1, superType, loader);
+        return isAssignableFrom(t1, superType, classLookup);
     }
 
     /**
@@ -139,7 +138,7 @@
      * @param clName
      * @return
      */
-    public static String getSuperClass(final String clName, final ClassLoader loader) {
+    public static String getSuperClass(final String clName, final ClassLookup classLookup) {
         if (clName == null) {
             return null;
         }
@@ -148,10 +147,10 @@
             return loaded;
         }
         try {
-            ClassInfo ci = getClassInfo(clName, loader);
+            ClassInfo ci = getClassInfo(clName, classLookup);
             String superName = ci.getSuperName();
             class_superclass.put(clName, superName);
-            detectInterfaces(clName, ci, loader);
+            detectInterfaces(clName, ci, classLookup);
             return superName;
         } catch (IOException e) {
             System.err.println("Failed to read class: " + clName + ". Reason: " + e.getMessage());
@@ -168,13 +167,13 @@
      * @param ci
      * @throws IOException
      */
-    static void detectInterfaces(String clName, ClassInfo ci, final ClassLoader loader)
+    static void detectInterfaces(String clName, ClassInfo ci, final ClassLookup classLookup)
             throws IOException {
         if (class_interfaces.get(clName) != null) {
             return;
         }
         if (ci == null) {
-            ci = getClassInfo(clName, loader);
+            ci = getClassInfo(clName, classLookup);
             String superName = ci.getSuperName();
             class_superclass.put(clName, superName);
         }
@@ -184,7 +183,7 @@
         if (interfaces != null) {
             for (String itf : interfaces) {
                 list.add(itf);
-                detectInterfaces(itf, null, loader);
+                detectInterfaces(itf, null, classLookup);
                 list.addAll(class_interfaces.get(itf));
             }
         }
@@ -206,29 +205,13 @@
      * @throws IOException when class can not be read (not found in loader or
      * can't be read by ClassReader)
      */
-    public static ClassInfo getClassInfo(final String clName, final ClassLoader loader) throws IOException {
+    public static ClassInfo getClassInfo(final String clName, final ClassLookup classLookup) throws IOException {
 
         ClassInfo classInfo;
 
-        if (loader instanceof JREInstr.StaticJREInstrClassLoader) {
-            InputStream in = getInputStreamForName(clName, loader, false, ".class");
+        InputStream in = classLookup.findClass(clName);
 
-            if (in == null) {
-                in = getInputStreamForName(clName, ClassLoader.getSystemClassLoader(), false, ".class");
-
-                if (in == null) {
-                    throw new IOException("Can't read class " + clName + " from classloader " + loader);
-                }
-
-                ClassReader cr = new OffsetLabelingClassReader(in);
-                classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());
-                try{
-                    in.close();
-                }
-                catch (Throwable ignore){}
-                return classInfo;
-            }
-
+        if (in != null) {
             ClassReader cr = new OffsetLabelingClassReader(in);
             classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());
             try{
@@ -238,103 +221,26 @@
             return classInfo;
         }
 
-        InputStream in = getInputStreamForName(clName, ClassLoader.getSystemClassLoader(), false, ".class");
-        String superClassName = null;
-        String[] interfaceNames = null;
-        if (in == null){
-            try {
-                Class cClass = Class.forName(clName.replace("/", "."));
+        try {
+            Class cClass = Class.forName(clName.replace("/", "."));
 
-                superClassName = "java/lang/Object";
-                if (cClass.getSuperclass() != null) {
-                    superClassName = cClass.getSuperclass().getName();
+            String superClassName = "java/lang/Object";
+            if (cClass.getSuperclass() != null) {
+                superClassName = cClass.getSuperclass().getName();
+            }
+            Class[] iclasses = cClass.getInterfaces();
+            String[] interfaceNames = null;
+            if (iclasses != null) {
+                interfaceNames = new String[iclasses.length];
+                for (int i = 0; i < iclasses.length; i++) {
+                    interfaceNames[i] = iclasses[i].getName();
                 }
-                Class[] iclasses = cClass.getInterfaces();
-                if (iclasses != null) {
-                    interfaceNames = new String[iclasses.length];
-                    for (int i = 0; i < iclasses.length; i++) {
-                        interfaceNames[i] = iclasses[i].getName();
-                    }
-                }
-            } catch (ClassNotFoundException e) {
             }
+            return new ClassInfo(superClassName, interfaceNames);
+        } catch (ClassNotFoundException e) {
         }
 
-        if (in == null && superClassName == null) {
-
-            in = getInputStreamForName(clName, ClassLoader.getSystemClassLoader(), false, ".clazz");
-
-            if (in == null) {
-                if (!ClassLoader.getSystemClassLoader().equals(loader)) {
-                    in = getInputStreamForName(clName, loader, false, ".class");
-                    if (in != null) {
-                        ClassReader cr = new OffsetLabelingClassReader(in);
-                        classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());
-                        try{
-                            in.close();
-                        }
-                        catch (Throwable ignore){}
-                        return classInfo;
-                    } else {
-                        throw new IOException("Can't read class " + clName + " from classloader " + loader);
-                    }
-                }
-
-                throw new IOException("Can't read class " + clName + " from classloader " + loader);
-            }
-
-        }
-
-        if (superClassName == null) {
-            ClassReader cr = new OffsetLabelingClassReader(in);
-            classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());
-            try {
-                in.close();
-            } catch (Throwable ignore) {
-            }
-        }
-        else{
-            classInfo = new ClassInfo(superClassName, interfaceNames);
-        }
-        return classInfo;
-    }
-
-    /**
-     *
-     * @param name
-     * @param loader
-     * @param priveleged if false - will try to use doPriveleged() mode
-     * @return
-     */
-    private static InputStream getInputStreamForName(final String name, final ClassLoader loader, boolean priveleged, final String ext) {
-        try {
-            InputStream in = loader.getResourceAsStream(name + ext);
-            if (in != null) {
-                return in;
-            }
-        } catch (Throwable ignore) {
-        }
-
-        for (int i = 0; i < customExtentions.length; ++i) {
-            try {
-                InputStream in = loader.getResourceAsStream(name + "." + customExtentions[i]);
-                if (in != null) {
-                    return in;
-                }
-            } catch (Throwable ignore) {
-            }
-        }
-
-        // trying to get class with priveleges
-        if (!priveleged) {
-            return AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
-                public InputStream run() {
-                    return getInputStreamForName(name, loader, true, ext);
-                }
-            });
-        }
-
-        return null;
+        throw new IOException("Can't read class " + clName + " from lookup " + classLookup);
     }
 
     private static class ClassInfo{
@@ -355,4 +261,67 @@
         }
 
     }
+
+    private static final class ClassLoaderLookup implements ClassLookup {
+        private final ClassLoader loader;
+
+        public ClassLoaderLookup(ClassLoader loader) {
+            this.loader = loader;
+        }
+
+        public InputStream findClass(String name) {
+            InputStream in = getInputStreamForName(name, loader, true, ".class");
+
+            if (in == null) {
+                in = getInputStreamForName(name, loader, true, ".clazz");
+            }
+
+            return in;
+        }
+
+        /**
+         *
+         * @param name
+         * @param loader
+         * @param priveleged if false - will try to use doPriveleged() mode
+         * @return
+         */
+        private InputStream getInputStreamForName(final String name, final ClassLoader loader, boolean priveleged, final String ext) {
+            try {
+                InputStream in = loader.getResourceAsStream(name + ext);
+                if (in != null) {
+                    return in;
+                }
+            } catch (Throwable ignore) {
+            }
+
+            for (int i = 0; i < customExtentions.length; ++i) {
+                try {
+                    InputStream in = loader.getResourceAsStream(name + "." + customExtentions[i]);
+                    if (in != null) {
+                        return in;
+                    }
+                } catch (Throwable ignore) {
+                }
+            }
+
+            // trying to get class with priveleges
+            if (!priveleged) {
+                return AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
+                    public InputStream run() {
+                        return getInputStreamForName(name, loader, true, ext);
+                    }
+                });
+            }
+
+            return null;
+        }
+    };
+
+    public static ClassLookup forClassLoader(ClassLoader cl) {
+        return new ClassLoaderLookup(cl);
+    }
+
+    public static final ClassLookup DEFAULT_CLASS_LOOKUP = forClassLoader(ClassLoader.getSystemClassLoader());
+
 }
diff --git a/src/classes/com/sun/tdk/jcov/instrument/SavePointsMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/SavePointsMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/SavePointsMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/SavePointsMethodAdapter.java
@@ -41,7 +41,7 @@
     private final boolean isBegin;
 
     public SavePointsMethodAdapter(final MethodVisitor mv, boolean isBegin) {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         this.isBegin = isBegin;
     }
 
diff --git a/src/classes/com/sun/tdk/jcov/instrument/StaticInvokeMethodAdapter.java b/src/classes/com/sun/tdk/jcov/instrument/StaticInvokeMethodAdapter.java
--- a/src/classes/com/sun/tdk/jcov/instrument/StaticInvokeMethodAdapter.java
+++ b/src/classes/com/sun/tdk/jcov/instrument/StaticInvokeMethodAdapter.java
@@ -63,7 +63,7 @@
     public static final Map<String, Integer> map = new HashMap<String, Integer>();
 
     public StaticInvokeMethodAdapter(MethodVisitor mv, String className, String methName, int access, final InstrumentationParams params) {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         this.className = className;
         this.params = params;
         this.methName = methName;
diff --git a/src/classes/com/sun/tdk/jcov/io/Reader.java b/src/classes/com/sun/tdk/jcov/io/Reader.java
--- a/src/classes/com/sun/tdk/jcov/io/Reader.java
+++ b/src/classes/com/sun/tdk/jcov/io/Reader.java
@@ -36,10 +36,15 @@
 import com.sun.tdk.jcov.instrument.reader.ReaderFactory;
 import com.sun.tdk.jcov.tools.SimpleScaleCompressor;
 import com.sun.tdk.jcov.util.Utils;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStreamReader;
 import java.nio.charset.Charset;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Iterator;
+import java.util.stream.Stream;
 
 /**
  * @author Dmitry Fazunenko
@@ -64,62 +69,93 @@
         return readXML(fileName, true, null);
     }
 
-    public static DataRoot readXML(InputStream is) throws FileFormatException {
-        return readXML(is, true, null);
-    }
+//    public static DataRoot readXML(InputStream is) throws FileFormatException {
+//        return readXML(is, true, null);
+//    }
 
     public static DataRoot readXML(String fileName, boolean read_scales,
             MemberFilter filter) throws FileFormatException {
-        FileInputStream in = null;
-        try {
-            File f = new File(fileName);
-            if (!f.exists()) {
-                throw new FileFormatException("File " + fileName + " doesn''t exist");
-            }
-
-            in = new FileInputStream(f);
-            DataRoot dataRoot = readXML(in, read_scales, filter);
-            dataRoot.setStorageFileName(fileName);
-            in.close();
-            in = null;
-
-            return dataRoot;
-        } catch (Exception e) {
-            if (!(e instanceof FileFormatException)) {
-                throw new FileFormatException(e.getMessage(), e);
-            } else {
-                throw (FileFormatException) e;
-            }
-        } finally {
-            if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException ex) {/*do nothing*/
-
-                }
-            }
-        }
-    }
-
-    public static DataRoot readXML(InputStream input, boolean read_scales,
-            MemberFilter filter) throws FileFormatException {
-
         DataRoot root = new DataRoot("", false);
         ScaleOptions scaleOpts = new ScaleOptions(read_scales, 0, new SimpleScaleCompressor());
         root.setScaleOpts(scaleOpts);
         root.setAcceptor(filter);
 
-        ReaderFactory rf = ReaderFactory.newInstance(Utils.getJavaVersion(), input);
-        root.setReaderFactory(rf);
-        root.readDataFrom();
+        File f = new File(fileName);
+        if (!f.exists()) {
+            throw new FileFormatException("File " + fileName + " doesn''t exist");
+        }
+
+        try (Stream<Path> files = Files.walk(f.toPath())) {
+            Iterator<Path> it = files.iterator();
+
+            while (it.hasNext()) {
+                Path p = it.next();
+
+                if (!Files.isRegularFile(p) || !p.getFileName().toString().endsWith(".xml"))
+                    continue;
+
+                try (InputStream in = Files.newInputStream(p)) {
+                    ReaderFactory rf = ReaderFactory.newInstance(Utils.getJavaVersion(), in);
+                    root.setReaderFactory(rf);
+                    root.readDataFrom();
+                }
+            }
+        } catch (IOException ex) {
+            throw new FileFormatException(ex);
+        }
 
         if (read_scales && scaleOpts.getScaleSize() == 0) {
             root.createScales();
         }
 
+        root.setStorageFileName(fileName);
+
         return root;
+//        FileInputStream in = null;
+//        try {
+//
+//            in = new FileInputStream(f);
+//            DataRoot dataRoot = readXML(in, read_scales, filter);
+//            in.close();
+//            in = null;
+//
+//            return dataRoot;
+//        } catch (Exception e) {
+//            if (!(e instanceof FileFormatException)) {
+//                throw new FileFormatException(e.getMessage(), e);
+//            } else {
+//                throw (FileFormatException) e;
+//            }
+//        } finally {
+//            if (in != null) {
+//                try {
+//                    in.close();
+//                } catch (IOException ex) {/*do nothing*/
+//
+//                }
+//            }
+//        }
     }
 
+//    public static DataRoot readXML(InputStream input, boolean read_scales,
+//            MemberFilter filter) throws FileFormatException {
+//
+//        DataRoot root = new DataRoot("", false);
+//        ScaleOptions scaleOpts = new ScaleOptions(read_scales, 0, new SimpleScaleCompressor());
+//        root.setScaleOpts(scaleOpts);
+//        root.setAcceptor(filter);
+//
+//        ReaderFactory rf = ReaderFactory.newInstance(Utils.getJavaVersion(), input);
+//        root.setReaderFactory(rf);
+//        root.readDataFrom();
+//
+//        if (read_scales && scaleOpts.getScaleSize() == 0) {
+//            root.createScales();
+//        }
+//
+//        return root;
+//    }
+
     public static DataRoot readXMLHeader(String fileName) throws FileFormatException {
         try {
             return readXMLHeader(new FileInputStream(fileName));
diff --git a/src/classes/com/sun/tdk/jcov/report/ClassCoverage.java b/src/classes/com/sun/tdk/jcov/report/ClassCoverage.java
--- a/src/classes/com/sun/tdk/jcov/report/ClassCoverage.java
+++ b/src/classes/com/sun/tdk/jcov/report/ClassCoverage.java
@@ -365,6 +365,9 @@
         return lineCoverage.isLineAnc(lineNum);
     }
 
+    public long getLastLine() {
+        return lineCoverage.lastLine();
+    }
     public void setAncInfo(String ancInfo){
         isInAnc = (ancInfo != null && !ancInfo.isEmpty());
         this.ancInfo = ancInfo;
diff --git a/src/classes/com/sun/tdk/jcov/report/ProductCoverage.java b/src/classes/com/sun/tdk/jcov/report/ProductCoverage.java
--- a/src/classes/com/sun/tdk/jcov/report/ProductCoverage.java
+++ b/src/classes/com/sun/tdk/jcov/report/ProductCoverage.java
@@ -99,6 +99,10 @@
         this(readFileImage(filename, true), null, null, null, true);
     }
 
+    public ProductCoverage(String filename, AncFilter[] ancfilters) throws FileFormatException {
+        this(readFileImage(filename, true), null, null, null, true, false, ancfilters);
+    }
+
     /**
      * <p> Creates a new instance of ProductCoverage which is the top level
      * coverage object in the coverage objects tree. DataRoot is read from
diff --git a/src/classes/com/sun/tdk/jcov/runtime/Collect.java b/src/classes/com/sun/tdk/jcov/runtime/Collect.java
--- a/src/classes/com/sun/tdk/jcov/runtime/Collect.java
+++ b/src/classes/com/sun/tdk/jcov/runtime/Collect.java
@@ -309,6 +309,12 @@
             isInternal = true;
             if (PropertyFinder.isVMReady()) {
                 loadSaverExtension();
+                String saverClassnameString = Collect.saverClassnameString;
+
+                if (saverClassnameString.startsWith("/*@")) {
+                    saverClassnameString = System.getProperty("jcov.test.saverClassnameString", saverClassnameString);
+                }
+
                 if (!saverClassnameString.startsWith("/*@")) {
                     addSaver(instantiateSaver(saverClassnameString));
                     PropertyFinder.addAutoShutdownSave();
diff --git a/src/classes/com/sun/tdk/jcov/runtime/TemplateFileSaver.java b/src/classes/com/sun/tdk/jcov/runtime/DumpSaver.java
copy from src/classes/com/sun/tdk/jcov/runtime/TemplateFileSaver.java
copy to src/classes/com/sun/tdk/jcov/runtime/DumpSaver.java
--- a/src/classes/com/sun/tdk/jcov/runtime/TemplateFileSaver.java
+++ b/src/classes/com/sun/tdk/jcov/runtime/DumpSaver.java
@@ -24,48 +24,61 @@
  */
 package com.sun.tdk.jcov.runtime;
 
-import com.sun.tdk.jcov.util.MapHelper;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.BitSet;
+
 
 /**
  * @author Dmitry Fazunenko
  * @author Alexey Fedorchenko
  */
-public class TemplateFileSaver implements JCovSaver {
+public class DumpSaver implements JCovSaver {
 
-    /**
-     * Default value for output file
-     */
-    private static final String def_filename_xml = "result.xml";
-    /**
-     * Default value for template file
-     */
-    private static final String def_template = "template.xml";
-    private String filename = def_filename_xml;
-    private String template = def_template;
-
-    public TemplateFileSaver() {
-    }
-
-    public TemplateFileSaver(String filename, String template) {
-        this.filename = filename;
-        this.template = template;
+    public DumpSaver() {
     }
 
     public void saveResults() {
-        template = PropertyFinder.findValue("template", template);
-        filename = PropertyFinder.findValue("file", filename);
+        String targetFile = PropertyFinder.findValue("target.file", null);
+        
+        try {
+            byte[] originalData = new byte[0];
+            try (InputStream in = new FileInputStream(targetFile);
+                 DataInputStream din = new DataInputStream(in)) {
+                originalData = new byte[din.readInt()];
+                din.readFully(originalData);
+            } catch (IOException ex) {
+                //ok
+            }
 
-        try {
-            MapHelper.mapCounts(filename, template, Collect.counts());
+            try (OutputStream out = new FileOutputStream(targetFile);
+                 DataOutputStream dout = new DataOutputStream(out)) {
+                BitSet data = new BitSet();
+                long[] counts = Collect.counts();
+                for (int i = 0; i < counts.length; i++) {
+                    if (counts[i] > 0)
+                        data.set(i);
+                }
+                byte[] packedData = data.toByteArray();
+                for (int i = 0; i < Math.min(packedData.length, originalData.length); i++) {
+                    packedData[i] |= originalData[i];
+                }
+                dout.writeInt(packedData.length);
+                dout.write(packedData);
+            }
         } catch (Exception e) {
             System.err.println(
-                    "Exception occurred while saving result into " + filename + " file.\n"
-                    + "Template file: " + template + "\n"
+                    "Exception occurred while saving result into " + targetFile + " file.\n"
                     + "Exception details: " + e.getMessage());
-            if (PropertyFinder.findValue("verbose", null) != null) {
+//            if (PropertyFinder.findValue("verbose", null) != null) {
                 System.err.println("\nStack trace: ");
                 e.printStackTrace(System.err);
-            }
+//            }
         }
     }
 }
diff --git a/src/classes/com/sun/tdk/jcov/runtime/JCovSESocketSaver.java b/src/classes/com/sun/tdk/jcov/runtime/JCovSESocketSaver.java
--- a/src/classes/com/sun/tdk/jcov/runtime/JCovSESocketSaver.java
+++ b/src/classes/com/sun/tdk/jcov/runtime/JCovSESocketSaver.java
@@ -107,7 +107,7 @@
             final long[] dataVal = new long[data.length];
             final int[] dataIdx = new int[data.length];
             int lastIndex = 0;
-            for (int i = 0; i < Collect.MAX_SLOTS; i++) {
+            for (int i = 0; i < data.length; i++) {
                 if (data[i] != 0) {
                     dataIdx[count] = i;
                     dataVal[count] = data[i];
diff --git a/src/classes/com/sun/tdk/jcov/runtime/JCovXMLFileSaver.java b/src/classes/com/sun/tdk/jcov/runtime/JCovXMLFileSaver.java
--- a/src/classes/com/sun/tdk/jcov/runtime/JCovXMLFileSaver.java
+++ b/src/classes/com/sun/tdk/jcov/runtime/JCovXMLFileSaver.java
@@ -32,6 +32,7 @@
 import com.sun.tdk.jcov.instrument.XmlContext;
 import com.sun.tdk.jcov.io.Reader;
 import com.sun.tdk.jcov.util.RuntimeUtils;
+
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.PrintStream;
@@ -40,7 +41,11 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileLock;
 import java.nio.channels.OverlappingFileLockException;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 
 /**
  *
@@ -61,7 +66,28 @@
 
     public void saveResults(String filename) throws Exception {
         //if (isWindows) {
+        Map<String, List<DataClass>> fileName2Classes = new HashMap<>();
+        for (DataClass clazz : root.getClasses()) {
+            if (clazz.getSource() == null) {
+                continue; //no source - ignore
+            }
+            fileName2Classes.computeIfAbsent(clazz.getPackageName().replace('.', '/') + "/" + clazz.getSource().replaceAll(".java$", ""), n -> new ArrayList<>()).add(clazz);
+        }
+        for (Entry<String, List<DataClass>> e : fileName2Classes.entrySet()) {
+            DataRoot newRoot = new DataRoot(root.getArgs(), root.isAttached(), root.getParams());
+            try {
+                for (DataClass clazz : e.getValue()) {
+                    newRoot.addClass(clazz);
+                }
+                doSaveResults(newRoot, filename + "/" + e.getKey() + ".xml");
+            } finally {
+                newRoot.destroy();
+            }
+        }
+    }
+    private void doSaveResults(DataRoot root, String filename) throws Exception {
             File file = new File(filename);
+            file.getParentFile().mkdirs();
             FileChannel channel = new RandomAccessFile(file, "rw").getChannel();
 
             for (int i = LOCK_REPEAT; i != 0; i--) {
diff --git a/test/jcov/InstrumentTest.java b/test/jcov/InstrumentTest.java
new file mode 100644
--- /dev/null
+++ b/test/jcov/InstrumentTest.java
@@ -0,0 +1,252 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package jcov;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.Consumer;
+
+import javax.tools.DiagnosticListener;
+import javax.tools.JavaCompiler;
+import javax.tools.JavaFileObject;
+import javax.tools.JavaFileObject.Kind;
+import javax.tools.SimpleJavaFileObject;
+import javax.tools.ToolProvider;
+
+import com.sun.tdk.jcov.Grabber;
+import com.sun.tdk.jcov.Instr;
+import com.sun.tdk.jcov.instrument.ClassLookup;
+import com.sun.tdk.jcov.report.AbstractCoverage;
+import com.sun.tdk.jcov.report.ClassCoverage;
+import com.sun.tdk.jcov.report.CoverageData;
+import com.sun.tdk.jcov.report.DataType;
+import com.sun.tdk.jcov.report.ItemCoverage;
+import com.sun.tdk.jcov.report.MethodCoverage;
+import com.sun.tdk.jcov.report.PackageCoverage;
+import com.sun.tdk.jcov.report.ProductCoverage;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**TODO: test that Collect's nextSlot is set to a viable value on each run?
+ *
+ * @author lahvac
+ */
+public class InstrumentTest {
+
+    private static final int DELAY = 1000; //TODO: Win: 2000ms!
+
+    @Test
+    public void testInstrumentModifier() throws Exception {
+        File tempDir = Files.createTempDirectory("jcov").toFile();
+        File classes = new File(tempDir, "classes");
+        File instrumented = new File(tempDir, "instrumented");
+        File template = new File(tempDir, "template");
+        File data = new File(tempDir, "data");
+
+        classes.mkdirs();
+
+        compile(classes, new FileDesc("a/A.java",
+                                      "package a;\n" +
+                                      "public class A {\n" +
+                                      "    public static void main(String... args) {\n" +
+                                      "        B.test(true);\n" +
+                                      "    }\n" +
+                                      "}\n"),
+                         new FileDesc("a/B.java",
+                                      "package a;\n" +
+                                      "public class B {\n" +
+                                      "    public static void test(boolean c) {\n" +
+                                      "        if (c) {\n" +
+                                      "            System.err.println(\"A\");\n" +
+                                      "        } else {\n" +
+                                      "            System.err.println(\"B\");\n" +
+                                      "        }\n" +
+                                      "    }\n" +
+                                      "}\n"));
+
+        instrument(classes, instrumented, template);
+
+        {
+            Set<Integer> seenLines = new HashSet<>();
+
+            runAndTest(instrumented, template, data, item -> {
+                if (item.getDataType() != DataType.BRANCH)
+                    return ;
+
+                CoverageData cov = item.getData(DataType.BRANCH);
+
+                switch (item.getSourceLine()) {
+                    case 5:
+                        Assert.assertEquals(cov.getTotal(), 1);
+                        Assert.assertEquals(cov.getCovered(), 1);
+                        break;
+                    case 7:
+                        Assert.assertEquals(cov.getTotal(), 1);
+                        Assert.assertEquals(cov.getCovered(), 0);
+                        break;
+                }
+
+                seenLines.add(item.getSourceLine());
+            });
+
+            Assert.assertEquals(seenLines, new HashSet<>(Arrays.asList(5, 7)));
+        }
+
+        //incremental instrumentation update:
+        Thread.sleep(DELAY);
+
+        File data2 = new File(tempDir, "data2");
+
+        compile(classes, new FileDesc("a/B.java",
+                                      "package a;\n" +
+                                      "public class B {\n" +
+                                      "    public static void test(boolean c) {\n" +
+                                      "        if (!c) {\n" +
+                                      "            System.err.println(\"A\");\n" +
+                                      "        } else {\n" +
+                                      "            System.err.println(\"B\");\n" +
+                                      "        }\n" +
+                                      "    }\n" +
+                                      "}\n"));
+        instrument(classes, instrumented, template);
+        //TODO: check timestamps to verify incrementatal instrumentation
+
+        {
+            Set<Integer> seenLines = new HashSet<>();
+
+            runAndTest(instrumented, template, data2, item -> {
+                if (item.getDataType() != DataType.BRANCH)
+                    return ;
+
+                CoverageData cov = item.getData(DataType.BRANCH);
+
+                switch (item.getSourceLine()) {
+                    case 5:
+                        Assert.assertEquals(cov.getTotal(), 1);
+                        Assert.assertEquals(cov.getCovered(), 0);
+                        break;
+                    case 7:
+                        Assert.assertEquals(cov.getTotal(), 1);
+                        Assert.assertEquals(cov.getCovered(), 1);
+                        break;
+                }
+
+                seenLines.add(item.getSourceLine());
+            });
+
+            Assert.assertEquals(seenLines, new HashSet<>(Arrays.asList(5, 7)));
+        }
+    }
+
+    private void compile(File target, FileDesc... sources) throws Exception {
+        List<JavaFileObject> sourceFiles = new ArrayList<>();
+
+        for (FileDesc source : sources) {
+            sourceFiles.add(new SimpleJavaFileObject(new URI("mem://" + source.fileName), Kind.SOURCE) {
+                @Override
+                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                    return source.code;
+                }
+            });
+        }
+
+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+        DiagnosticListener<? super JavaFileObject> noErrors = d -> {
+            if (d.getKind() == javax.tools.Diagnostic.Kind.ERROR)
+                throw new IllegalStateException(d.getMessage(null));
+        };
+
+        if (!compiler.getTask(null, null, noErrors, Arrays.asList("-d", target.toString()), null, sourceFiles).call()) {
+            throw new AssertionError();
+        }
+    }
+
+    private void instrument(File classes, File instrumented, File template) throws Exception {
+        Instr instr = new Instr();
+
+        instr.setClassLookup(new ClassLookup() {
+            @Override
+            public InputStream findClass(String name) {
+                return null;
+            }
+        });
+
+        instr.run(new String[] {"-o", instrumented.getAbsolutePath(), classes.getAbsolutePath(), "-template", template.getAbsolutePath()});
+    }
+
+    private void runAndTest(File instrumented, File template, File data, Consumer<ItemCoverage> verify) throws Exception {
+        Grabber g = new Grabber();
+
+        g.setPort(0);
+        g.setOutputFilename(data.getAbsolutePath());
+        g.setSaveOnReceive(true);
+        g.setTemplate(template.getAbsolutePath());
+        try {
+            g.createServer();
+        } catch (IOException ex) {
+            ex.printStackTrace();
+            return ;
+        }
+        try {
+            g.startServer();
+            final int port = g.getServerPort();
+            String runtime = com.sun.tdk.jcov.runtime.Collect.class.getProtectionDomain().getCodeSource().getLocation().getPath();
+            String javaHome = System.getProperty("java.home");
+            File javaLauncher = new File(javaHome, "bin/java");
+            List<String> options = Arrays.asList(javaLauncher.getAbsolutePath(), "-classpath", runtime + ":" + instrumented, "-Djcov.port=" + port, "-Djcov.test.saverClassnameString=com.sun.tdk.jcov.runtime.JCovSESocketSaver", "a.A");
+            Process p = new ProcessBuilder(options).inheritIO().start();
+            p.waitFor();
+        } finally {
+            g.stopServer(false);
+        }
+
+        ProductCoverage coverage = new ProductCoverage(data.getAbsolutePath());
+        PackageCoverage pack = findCoverage(coverage.getPackages(), "a");
+
+        Assert.assertNotNull(pack);
+
+        ClassCoverage bClass = findCoverage(pack.getClasses(), "B");
+
+        Assert.assertNotNull(bClass);
+
+        MethodCoverage testMethod = findCoverage(bClass.getMethods(), "test");
+
+        for (ItemCoverage cov : testMethod.getItems()) {
+            verify.accept(cov);
+        }
+    }
+
+    private <T extends AbstractCoverage> T findCoverage(Iterable<T> data, String name) {
+        for (T t : data) {
+            if (Objects.equals(t.getName(), name)) {
+                return t;
+            }
+        }
+
+        return null;
+    }
+
+    //TODO: partial load
+
+    public static final class FileDesc {
+        public final String fileName;
+        public final String code;
+
+        public FileDesc(String fileName, String code) {
+            this.fileName = fileName;
+            this.code = code;
+        }
+    }
+}
